/* This is a small demo of the high-performance GUIX graphics framework. */

#include <stdio.h>
#include "tx_api.h"
#include "gx_api.h"
#include "gx_system.h"
#include "gx_validation_utility.h"

TEST_PARAM test_parameter = {
    "guix_ml_text_input_drag_select", /* Test name */
    30, 120, 245, 330  /* Define the coordinates of the capture area.
                         In this test, we only need to capture the multi 
                         line text input drawing area.  */
};

static VOID      control_thread_entry(ULONG);
int main(int argc, char ** argv)
{
    /* Parse the command line argument. */
    gx_validation_setup(argc, argv);

    /* Start ThreadX system */
    tx_kernel_enter(); 
    return(0);
}

VOID tx_application_define(void *first_unused_memory)
{

    /* Create a dedicated thread to perform various operations
       on the multi line text input example. These operations simulate 
       user input. */
    gx_validation_control_thread_create(control_thread_entry);

    /* Terminate the test if it runs for more than 100 ticks */
    /* This function is not implemented yet. */
    gx_validation_watchdog_create(100);

    /* Call the actual multi line text input routine. */
    gx_validation_application_define(first_unused_memory);

}


/* Replace the default graphics driver with the validation driver. */
#ifdef win32_graphics_driver_setup_565rgb  
#undef win32_graphics_driver_setup_565rgb  
#endif
#define win32_graphics_driver_setup_565rgb  gx_validation_graphics_driver_setup_565rgb


#ifdef WIN32
#undef WIN32
#endif

#include "gx_validation_wrapper.h"

#include "demo_guix_ml_text_input_16bpp.c"

static GX_CONST GX_UBYTE CHINESE_TEXT[426] = { 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0xe6, 0x96, 0x87, 0xe6, 0x9c, 0xac, 0xe8, 0xbe, 0x93, 0xe5, 0x85, 0xa5, 0xe6, 0xa1, 0x86, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0xe6, 0x96, 0x87, 0xe6, 0x9c, 0xac, 0xe8, 0xbe, 0x93, 0xe5, 0x85, 0xa5, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0xe6, 0x96, 0x87, 0xe6, 0x9c, 0xac, 0xe8, 0xbe, 0x93, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0xe6, 0x96, 0x87, 0xe6, 0x9c, 0xac, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0xe6, 0x96, 0x87, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0x0d, 0xe8, 0xbf, 0x99, 0x0d, 0xe8, 0xbf, 0x99, 0x0d, 0xe8, 0xbf, 0x99, 0x0d, 0xe8, 0xbf, 0x99, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0xe6, 0x96, 0x87, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0xe6, 0x96, 0x87, 0xe6, 0x9c, 0xac, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0xe6, 0x96, 0x87, 0xe6, 0x9c, 0xac, 0xe8, 0xbe, 0x93, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0xe6, 0x96, 0x87, 0xe6, 0x9c, 0xac, 0xe8, 0xbe, 0x93, 0xe5, 0x85, 0xa5, 0x0d, 0xe8, 0xbf, 0x99, 0xe6, 0x98, 0xaf, 0xe4, 0xb8, 0x80, 0xe4, 0xb8, 0xaa, 0xe5, 0xa4, 0x9a, 0xe8, 0xa1, 0x8c, 0xe6, 0x96, 0x87, 0xe6, 0x9c, 0xac, 0xe8, 0xbe, 0x93, 0xe5, 0x85, 0xa5, 0xe6, 0xa1, 0x86, 0x00 };

char *test_comment[1];


typedef struct TEST_STRUCT{
INT event_type;
GX_VALUE point_x;
GX_VALUE point_y;
INT      expected_frames;
GX_CHAR *comment;
}TEST;

TEST test_list[]={
{GX_EVENT_PEN_DOWN,  90, 221, 1, "pen down on (90, 221)"},
{GX_EVENT_PEN_DRAG, 121, 222, 1, "pen drag to (121, 222)"},/* Drag right. */
{GX_EVENT_PEN_DRAG, 105, 240, 1, "pen drag to (105, 240)"},/* Drag down*/
{GX_EVENT_PEN_DRAG,  54, 215, 1, "pen drag to (54, 215)"}, /* Drag left*/
{GX_EVENT_PEN_DRAG, 109, 193, 1, "pen drag to (109, 193)"},/* Drag up*/
{GX_EVENT_PEN_DRAG, 107, 123, 3, "pen drag to (107, 123)"},/* Drag up out of client area. */
{GX_EVENT_PEN_UP,    98, 158, 1, "pen up on (98, 158)"},/* Pen up in client area*/
{GX_EVENT_PEN_DOWN,  86, 282, 1, "pen down on (86, 282)"},
{GX_EVENT_PEN_DRAG,  96, 320, 3, "pen drag to (96, 320)"},/* Drag down out of client area. */
{GX_EVENT_PEN_UP,    87, 264, 1, "pen up on (87, 264)"},/* Pen up in client area*/
{GX_EVENT_PEN_DOWN,  86, 286, 1, "pen down on (86, 286)"},/* Drag up out of client area. */
{GX_EVENT_PEN_DRAG, 107, 123, 3, "pen drag to (107, 123)"},
{GX_EVENT_PEN_UP,   107, 123, 1, "pen up on (107, 123)"},
{0,                   0,   0, 0, ""}
};

/* This thread simulates user input.  Its priority is lower
   than the GUIX thread, so that GUIX finishes an operation 
   before this thread is able to issue the next command. */
static VOID control_thread_entry(ULONG input)
{
int                       frame_id = 1;
GX_MULTI_LINE_TEXT_INPUT *text_input;
GX_EVENT                  my_event;
TEST                     *test;

    text_input = &((WINDOW_CONTROL_BLOCK *)pMainScreen)->window_ml_text_input;

    memset(&my_event, 0, sizeof(GX_EVENT));
    my_event.gx_event_display_handle = 1;

    test_comment[0] = (GX_CHAR *)malloc(256);   

     /* Remove the cursor blink flag. */
    gx_multi_line_text_input_style_remove(text_input, GX_STYLE_CURSOR_BLINK);
    gx_multi_line_text_view_whitespace_set((GX_MULTI_LINE_TEXT_VIEW *)text_input, 1);
    gx_multi_line_text_view_line_space_set((GX_MULTI_LINE_TEXT_VIEW *)text_input, 4);
    gx_multi_line_text_view_font_set((GX_MULTI_LINE_TEXT_VIEW *)text_input, GX_FONT_ID_CHINESE);
    gx_multi_line_text_input_text_set(&window.window_ml_text_input, (GX_CONST GX_CHAR *)CHINESE_TEXT);
   
    gx_validation_set_frame_id(frame_id++);
    sprintf(test_comment[0], "set a string that is bigger than buffer size.");
    gx_validation_set_frame_comment(test_comment[0]);
    gx_validation_screen_refresh();

    test = test_list;

    while(test->event_type)
    {

        tx_thread_sleep(1);
        gx_validation_current_frame_id_get(&frame_id);
        frame_id++;
        if(test->expected_frames == 1)
        {
            gx_validation_set_frame_id(frame_id);
            gx_validation_set_frame_comment(test->comment);
        }
GX_ENTER_CRITICAL
        if(test->expected_frames > 1)
        {
            sprintf(test_comment[0], "%s, start capture", test->comment);
            /* start_id, expected frames, comments, num_comments, max_time. */
            gx_validation_capture_frames(frame_id, test->expected_frames, (GX_CHAR **)test_comment, 1, 100);
        }

        my_event.gx_event_type = test->event_type;
        my_event.gx_event_display_handle = 1;
        my_event.gx_event_payload.gx_event_pointdata.gx_point_x = test->point_x;
        my_event.gx_event_payload.gx_event_pointdata.gx_point_y = test->point_y;

        gx_system_event_send(&my_event);

GX_EXIT_CRITICAL
        gx_validation_capture_frames_wait();
        test++;
    }

    free(test_comment[0]);
    gx_validation_end();

    exit(0);
}
