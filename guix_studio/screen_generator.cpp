              #include "studiox_includes.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#endif


STRING_VAL_PAIR PredefinedWidgetIds[] =
{
    { _T("ID_DROP_LIST_BUTTON"), ID_DROP_LIST_BUTTON},
};

CString SourceHeaderCommentStart(""
    "/*******************************************************************************/\n"
    "/*  This file is auto-generated by Azure RTOS GUIX Studio. Do not edit this    */\n"
    "/*  file by hand. Modifications to this file should only be made by running    */\n"
    "/*  the Azure RTOS GUIX Studio application and re-generating the application   */\n"
    "/*  specification file(s). For more information please refer to the Azure RTOS */\n"
    "/*  GUIX Studio User Guide, or visit our web site at azure.com/rtos            */\n"
    "/*                                                                             */\n"


);

extern CString SCREEN_STACK_POP_STRING;


///////////////////////////////////////////////////////////////////////////////
screen_generator::screen_generator(studiox_project *project)
{
    m_project = project;
    m_display = 0;
}

///////////////////////////////////////////////////////////////////////////////
screen_generator::~screen_generator()
{
}

///////////////////////////////////////////////////////////////////////////////
BOOL screen_generator::GenerateScreens(int display)
{

    /* Pickup command info. */
    CCommandInfo *pCmdInfo = GetCmdInfo();

    CString file_name;
    GotoProjectDirectory();

    file_name = m_project->mHeader.header_path;
    if (!file_name.IsEmpty())
    {
        if (file_name.GetAt(file_name.GetLength() - 1) != '\\')
        {
            file_name += "\\";
        }
    }

    if(pCmdInfo->GetSpecificationFileName().IsEmpty())
    {
        file_name += m_project->mHeader.project_name;
        file_name += "_specifications.h";
    }
    else
    {
        file_name += pCmdInfo->GetSpecificationFileName() + _T(".h");
    }

    if (m_outfile)
    {
        delete m_outfile;
    }

    m_outfile = new CFile();

    /* Generate head file. */
    if (!m_outfile->Open(file_name, CFile::modeCreate | CFile::modeWrite))
    {
        ErrorMsg("Count not open output file. Please check header file path.");
        delete m_outfile;
        m_outfile = NULL;
        return FALSE;
    }

    // make sure we don't have any empty screen flow:

    m_project->CheckEmptyScreenFlow();

    GenerateScreenHeader();
    m_outfile->Close();
    delete m_outfile;
    m_outfile = NULL;

    /* Generate c file. */
    file_name = m_project->mHeader.source_path;
    if (!file_name.IsEmpty())
    {
        if (file_name.GetAt(file_name.GetLength() - 1) != '\\')
        {
            file_name += "\\";
        }
    }

    m_output_filepath = file_name;

    if(pCmdInfo->GetSpecificationFileName().IsEmpty())
    {
        file_name = m_project->mHeader.project_name;
        file_name += "_specifications";
    }
    else
    {
        file_name += pCmdInfo->GetSpecificationFileName();
    }

    if (!SetOutFile(file_name))
    {
        return FALSE;
    }

    GenerateScreenSource();

    for (int index = 0; index < output_file_list.GetCount(); index++)
    {
        m_outfile = output_file_list.GetAt(index);
        CString out(_T("#undef GUIX_STUDIO_GENERATED_FILE\n"));
        FileWrite(out);

        m_outfile->Close();
        delete m_outfile;
    }
    m_outfile = NULL;
    output_file_list.RemoveAll();

    return TRUE;
}

void screen_generator::WriteErrorDirectives()
{
    CString out;

    if (project_lib_version() < GX_VERSION_3BIT_GLYPH_DRAW_SUPPORT)
    {
        return;
    }

    for (int display = 0; display < m_project->mHeader.num_displays; display++)
    {

        if (IsDave2dFontFormat(m_project, display))
        {
            continue;
        }

        if (m_project->mDisplays[display].colorformat == GX_COLOR_FORMAT_8BIT_PALETTE)
        {
            out.Format(_T("\n#if GX_PALETTE_MODE_AA_TEXT_COLORS != %d\n"), m_project->mHeader.palette_mode_aa_text_colors);
            out += _T("#error \"The symbol GX_PALETTE_MODE_AA_TEXT_COLORS does not match the setting in the Studio project.\"\n");
            out += _T("#endif\n");

            FileWrite(out);
            return;
        }
    }
}

void screen_generator::DeclareScreenFlowStructures()
{
    CString out;

    out =  "#define GX_ACTION_FLAG_DYNAMIC_TARGET 0x01\n";
    out += "#define GX_ACTION_FLAG_DYNAMIC_PARENT 0x02\n";

    if (project_lib_version() > 50402)
    {
        out += "#define GX_ACTION_FLAG_POP_TARGET     0x04\n";
        out += "#define GX_ACTION_FLAG_POP_PARENT     0x08\n\n";
    }

    FileWrite(out);

    out =  "typedef struct GX_STUDIO_ACTION_STRUCT\n";
    out += "{\n";
    out += "    GX_UBYTE opcode;\n";
    out += "    GX_UBYTE flags;\n";
    out += "    GX_CONST VOID *parent;\n";
    out += "    GX_CONST VOID *target;\n";
    out += "    GX_CONST GX_ANIMATION_INFO  *animation;\n";
    out += "} GX_STUDIO_ACTION;\n\n";
    FileWrite(out);

    out =  "typedef struct GX_STUDIO_EVENT_ENTRY_STRUCT\n";
    out += "{\n";
    out += "    ULONG event_type;\n";
    out += "    USHORT event_sender;\n";
    out += "    GX_CONST GX_STUDIO_ACTION *action_list;\n";
    out += "} GX_STUDIO_EVENT_ENTRY;\n\n";

    FileWrite(out);

    out =  "typedef struct GX_STUDIO_EVENT_PROCESS_STRUCT \n";
    out += "{\n";
    out += "    GX_CONST GX_STUDIO_EVENT_ENTRY *event_table;\n";
    out += "    UINT (*chain_event_handler)(GX_WIDGET *, GX_EVENT *);\n";
    out += "} GX_STUDIO_EVENT_PROCESS;\n";

    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
BOOL screen_generator::ProjectHasScreenFlow()
{
    for (int display = 0; display < m_project->mHeader.num_displays; display++)
    {
        if (m_project->mDisplays[display].screenflow)
        {
            return TRUE;
        }
    }
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::GenerateScreenHeader()
{
    CString out;
    CString name = m_project->mHeader.project_name;
    name.MakeUpper();
    folder_info *folder;
    int display;

    WriteCommentBlock(SourceHeaderCommentStart);

    // write the sentry
    out.Format(_T("#ifndef _%s_SPECIFICATIONS_H_\n#define _%s_SPECIFICATIONS_H_\n\n"),
        name, name);
    FileWrite(out);
    FileWrite(CString("#include \"gx_api.h\"\n\n"));

    // write the "extern C"
    out = "/* Determine if C++ compiler is being used, if so use standard C.  */\n";
    out += "#ifdef __cplusplus\n";
    out += "extern   \"C\" {\n";
    out += "#endif\n";
    FileWrite(out);

    WriteErrorDirectives();

    name_list.RemoveAll();
    m_widget_id = 1;
    WriteComment("Define widget ids");

    for (display = 0; display < m_project->mHeader.num_displays; display++)
    {
        folder = m_project->mDisplays[display].GetFirstChildFolder();

        /*Wtite predefined widget ids.*/
        for (UINT index = 0; index < (UINT)(sizeof(PredefinedWidgetIds) / sizeof(STRING_VAL_PAIR)); index++)
        {
            name_list.Add(PredefinedWidgetIds[index].name);
        }
        
        WriteWidgetIds(folder);
    }
    BlankLine();

    WriteComment("Define animation ids");

    int index = 0;
    CArray<id_info> id_dictionary;
    id_info ani_info;
    for (display = 0; display < m_project->mHeader.num_displays; display++)
    {
        m_project->CopyIdDictionary(display, ID_TYPE_ANIMATION, &id_dictionary);
        m_project->SortIdDictionary(&id_dictionary);
        for (index = 1; index < id_dictionary.GetCount(); index++)
        {
            ani_info = id_dictionary.GetAt(index);
            out.Format(_T("#define %s %d\n"), ani_info.id_name, index);
            FileWrite(out);
        }
    }

    out.Format(_T("#define GX_NEXT_ANIMATION_ID %d\n"), index);
    FileWrite(out);

    BlankLine();

    WriteComment("Define user event ids");
    name_list.RemoveAll();
    int id = 0;
    for (display = 0; display < m_project->mHeader.num_displays; display++)
    {
        screen_flow *flow = m_project->mDisplays[display].screenflow;
        flow_item *item;
        trigger_info *trigger;

        if (flow)
        {
            for (index = 0; index < flow->GetFlowListCount(); index++)
            {
                item = flow->GetFlowItem(index);
                trigger = item->trigger_list;

                while (trigger)
                {
                    name = trigger->user_event_id_name;
                    if ((!name.IsEmpty()) && (!IsItemInArray<CString>(name_list, name)))
                    {
                        name_list.Add(name);
                        if (id == 0)
                        {
                            out.Format(_T("enum user_defined_events{\n")
                                _T("    %s = GX_FIRST_USER_EVENT,\n"), name);
                        }
                        else
                        {
                            out.Format(_T("    %s,\n"), name);
                        }
                        id++;
                        FileWrite(out);
                    }
                    trigger = trigger->next;
                }
            }
        }
    }
    if (id)
    {
        out = _T("    GX_NEXT_USER_EVENT_ID\n};\n");
    }
    else
    {
        out = _T("#define GX_NEXT_USER_EVENT_ID GX_FIRST_USER_EVENT\n");
    }
    FileWrite(out);
    BlankLine();


    if (ProjectHasScreenFlow())
    {
        DeclareScreenFlowStructures();
    }

    // declare the properties stuctures for each used widget type

    WriteComment("Declare properties structures for each utilized widget type");
    index = 0;

    while(1)
    {
        int widget_type = widget_factory::GetWidgetType(index);
        if (widget_type <= 0)
        {
            break;
        }
        if (widget_type == GX_TYPE_WIDGET ||
            widget_type == GX_TYPE_BUTTON ||
            widget_type == GX_TYPE_WINDOW ||
            IsWidgetUsed(widget_type))
        {
            widget_service_provider *provider = widget_factory::GetServiceProvider(widget_type);
            CString props = provider->DeclarePropertiesStruct();

            if (!props.IsEmpty())
            {
                FileWrite(props);
            }
        }
        index++;
    }

    WriteComment("Declare top-level control blocks");

    /* Continue writing control blocks, keeping track of those written,
       until we are able to write them all */

    name_list.RemoveAll();

    m_screen_name_prefix = _T("");
    for (display = 0; display < m_project->mHeader.num_displays; display++)
    {
        BOOL completed = FALSE;
        if (m_project->mHeader.num_displays > 1)
        {
            m_screen_name_prefix = m_project->mDisplays[display].name + _T("_");
        }

        while (!completed)
        {
            folder = m_project->mDisplays[display].GetFirstChildFolder();
            if (folder == NULL)
            {
                break;
            }
            completed = TypedefControlBlock(folder);
        }
    }

    if (IsCpuWithDave2D(m_project) && m_project->mHeader.guix_version >= 50300)
    {
        DeclareSynergyDriverFunctions();
    }

    WriteComment("Declare event process functions, draw functions, and callback functions");
    name_list.RemoveAll();

    for (display = 0; display < m_project->mHeader.num_displays; display++)
    {
        folder = m_project->mDisplays[display].GetFirstChildFolder();
        while (folder)
        {
            PrototypeCallbacks(folder->GetFirstChildWidget());
            folder = folder->GetNextFolder();
        }
    }

    WriteComment("Declare the GX_STUDIO_DISPLAY_INFO structure");

    if (m_project->mHeader.guix_version <= 50302)
    {
        FileWrite(CString("\n"
            "typedef struct GX_STUDIO_DISPLAY_INFO_STRUCT \n"
            "{\n"
            "    GX_CONST GX_CHAR *name;\n"
            "    GX_CONST GX_CHAR *canvas_name;\n"
            "    GX_CONST GX_THEME **theme_table;\n"
            "    GX_CONST GX_CHAR ***language_table;\n"
            "    UINT     language_table_size;\n"
            "    UINT     string_table_size;\n"
            "    UINT     x_resolution;\n"
            "    UINT     y_resolution;\n"
            "    GX_DISPLAY *display;\n"
            "    GX_CANVAS  *canvas;\n"
            "    GX_WINDOW_ROOT *root_window;\n"
            "    GX_COLOR   *canvas_memory;\n"
            "    ULONG      canvas_memory_size;\n"
            "} GX_STUDIO_DISPLAY_INFO;\n"));
    }
    else if(m_project->mHeader.guix_version < GX_VERSION_STRING_LENGTH_FIX)
    {
        // Add a new member variable "theme_table_size"
        FileWrite(CString("\n"
            "typedef struct GX_STUDIO_DISPLAY_INFO_STRUCT \n"
            "{\n"
            "    GX_CONST GX_CHAR *name;\n"
            "    GX_CONST GX_CHAR *canvas_name;\n"
            "    GX_CONST GX_THEME **theme_table;\n"
            "    GX_CONST GX_CHAR ***language_table;\n"
            "    USHORT   theme_table_size;\n"
            "    USHORT   language_table_size;\n"
            "    UINT     string_table_size;\n"
            "    UINT     x_resolution;\n"
            "    UINT     y_resolution;\n"
            "    GX_DISPLAY *display;\n"
            "    GX_CANVAS  *canvas;\n"
            "    GX_WINDOW_ROOT *root_window;\n"
            "    GX_COLOR   *canvas_memory;\n"
            "    ULONG      canvas_memory_size;\n"
            "} GX_STUDIO_DISPLAY_INFO;\n"));
    }
    else if(m_project->mHeader.guix_version < GX_VERSION_DISPLAY_ROTATION)
    {
        // Add a new member variable "theme_table_size"
        FileWrite(CString("\n"
            "typedef struct GX_STUDIO_DISPLAY_INFO_STRUCT \n"
            "{\n"
            "    GX_CONST GX_CHAR *name;\n"
            "    GX_CONST GX_CHAR *canvas_name;\n"
            "    GX_CONST GX_THEME **theme_table;\n"
            "    GX_CONST GX_STRING **language_table;\n"
            "    USHORT   theme_table_size;\n"
            "    USHORT   language_table_size;\n"
            "    UINT     string_table_size;\n"
            "    UINT     x_resolution;\n"
            "    UINT     y_resolution;\n"
            "    GX_DISPLAY *display;\n"
            "    GX_CANVAS  *canvas;\n"
            "    GX_WINDOW_ROOT *root_window;\n"
            "    GX_COLOR   *canvas_memory;\n"
            "    ULONG      canvas_memory_size;\n"
            "} GX_STUDIO_DISPLAY_INFO;\n"));
    }
    else
    {
        CString out;
        CString language_direction_table("");

        if (string_table::TestGenerateLanguageDirectionTable())
        {
            language_direction_table = _T("    GX_CONST GX_UBYTE *language_direction_table;\n");
        }

        // Add a new member variable "theme_table_size"
        out.Format(_T("\n")
            _T("typedef struct GX_STUDIO_DISPLAY_INFO_STRUCT \n")
            _T("{\n")
            _T("    GX_CONST GX_CHAR *name;\n")
            _T("    GX_CONST GX_CHAR *canvas_name;\n")
            _T("    GX_CONST GX_THEME **theme_table;\n")
            _T("    GX_CONST GX_STRING **language_table;\n%s")
            _T("    USHORT   theme_table_size;\n")
            _T("    USHORT   language_table_size;\n")
            _T("    UINT     string_table_size;\n")
            _T("    UINT     x_resolution;\n")
            _T("    UINT     y_resolution;\n")
            _T("    GX_DISPLAY *display;\n")
            _T("    GX_CANVAS  *canvas;\n")
            _T("    GX_WINDOW_ROOT *root_window;\n")
            _T("    GX_COLOR   *canvas_memory;\n")
            _T("    ULONG      canvas_memory_size;\n")
            _T("    USHORT     rotation_angle;\n")
            _T("} GX_STUDIO_DISPLAY_INFO;\n"), language_direction_table);

        FileWrite(out);
    }

    /* write out the two function prototypes */
    BlankLine();
    WriteComment("Declare Studio-generated functions for creating top-level widgets");
    index = 0;

    while(1)
    {
        int widget_type = widget_factory::GetWidgetType(index);

        if (!widget_type)
        {
            break;
        }
        if (IsWidgetUsed(widget_type))
        {
            widget_service_provider *provider = widget_factory::GetServiceProvider(widget_type);
            if (provider)
            {
                out.Format(_T("UINT %s(GX_CONST GX_STUDIO_WIDGET *info, GX_WIDGET *control_block, GX_WIDGET *parent);\n"), provider->GetCreateFromDefFunctionName());
                FileWrite(out);
            }
        }
        index++;
    }

    if (project_lib_version() < 50100)
    {
        FileWrite(CString("GX_WIDGET *gx_studio_widget_create(GX_STUDIO_WIDGET *definition, GX_WIDGET *parent);\n"
            "UINT gx_studio_named_widget_create(char *name, GX_WIDGET *parent, GX_WIDGET **new_widget);\n"
            "UINT gx_studio_display_configure(USHORT display, UINT (*driver)(GX_DISPLAY *), USHORT language, USHORT theme, GX_WINDOW_ROOT **return_root);\n"));
    }
    else if (project_lib_version() < 50402)
    {
        FileWrite(CString("GX_WIDGET *gx_studio_widget_create(GX_BYTE *storage, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent);\n"
            "UINT gx_studio_named_widget_create(char *name, GX_WIDGET *parent, GX_WIDGET **new_widget);\n"
            "UINT gx_studio_display_configure(USHORT display, UINT (*driver)(GX_DISPLAY *), USHORT language, USHORT theme, GX_WINDOW_ROOT **return_root);\n"));
    }
    else
    {
        FileWrite(CString("GX_WIDGET *gx_studio_widget_create(GX_BYTE *storage, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent);\n"
            "UINT gx_studio_named_widget_create(char *name, GX_WIDGET *parent, GX_WIDGET **new_widget);\n"
            "UINT gx_studio_display_configure(USHORT display, UINT (*driver)(GX_DISPLAY *), GX_UBYTE language, USHORT theme, GX_WINDOW_ROOT **return_root);\n"));
    }

    if (ProjectHasScreenFlow())
    {
        /* Write screen flow auto event handler function. */
        out = "UINT gx_studio_auto_event_handler(GX_WIDGET *widget, GX_EVENT *event_ptr, GX_CONST GX_STUDIO_EVENT_PROCESS *record);\n";
        FileWrite(out);
    }

    // terminate the extern  'C'
    out = "\n/* Determine if a C++ compiler is being used.  If so, complete the standard\n";
    out += "  C conditional started above.  */\n";
    out += "#ifdef __cplusplus\n";
    out += "}\n";
    out += "#endif\n";
    FileWrite(out);

    // terminate the sentry
    FileWrite(CString("\n#endif      /* sentry */\n"));

}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteDisplayConfigure()
{
    CString out;

    if (project_lib_version() < 50402)
    {
        FileWrite(CString("\nUINT gx_studio_display_configure(USHORT display, UINT (*driver)(GX_DISPLAY *),\n"
            "    USHORT language, USHORT theme, GX_WINDOW_ROOT **return_root)\n"
            "{\n"
            "    GX_CONST GX_THEME *theme_ptr;\n"
            "    GX_RECTANGLE size;\n"
            "\n"));
    }
    else
    {
        FileWrite(CString("\nUINT gx_studio_display_configure(USHORT display, UINT (*driver)(GX_DISPLAY *),\n"
            "    GX_UBYTE language, USHORT theme, GX_WINDOW_ROOT **return_root)\n"
            "{\n"
            "    GX_CONST GX_THEME *theme_ptr;\n"
            "    GX_RECTANGLE size;\n"
            "\n"));
    }
    
    out.Format(_T("    GX_STUDIO_DISPLAY_INFO *display_info = &%s_display_table[display];\n"),
        m_project->mHeader.project_name);
    FileWrite(out);

    //CString upper_display_name =  m_project->mDisplays[m_display].name;
    //upper_display_name.MakeUpper();

    out.Format(_T("\n\n")
        _T("/* create the requested display */\n\n")
        _T("    gx_display_create(display_info->display,\n")
        _T("                      display_info->name,\n")
        _T("                      driver,\n")
        _T("                      (GX_VALUE) display_info->x_resolution,\n")
        _T("                      (GX_VALUE) display_info->y_resolution);\n"));
    FileWrite(out);

    CCommandInfo *pCmdInfo = GetCmdInfo();

    out.Format(_T("\n\n/* install the request theme */\n\n")
        _T("    if(display_info->theme_table)\n")
        _T("    {\n")
        _T("        theme_ptr = display_info->theme_table[theme];\n")
        _T("        if(theme_ptr)\n")
        _T("        {\n")
        _T("            gx_display_color_table_set(display_info->display, theme_ptr->theme_color_table, theme_ptr->theme_color_table_size);\n")
        _T("            \n/* install the color palette if required */\n")
        _T("            if (display_info->display->gx_display_driver_palette_set &&\n")
        _T("                theme_ptr->theme_palette != NULL)\n")
        _T("            {\n")
        _T("                display_info->display->gx_display_driver_palette_set(display_info->display, theme_ptr->theme_palette, theme_ptr->theme_palette_size);\n")
        _T("            }\n\n")
        _T("            gx_display_font_table_set(display_info->display, theme_ptr->theme_font_table, theme_ptr->theme_font_table_size);\n")
        _T("            gx_display_pixelmap_table_set(display_info->display, theme_ptr->theme_pixelmap_table, theme_ptr->theme_pixelmap_table_size);\n")
        _T("            gx_system_scroll_appearance_set(theme_ptr->theme_vertical_scroll_style, (GX_SCROLLBAR_APPEARANCE *) &theme_ptr->theme_vertical_scrollbar_appearance);\n")
        _T("            gx_system_scroll_appearance_set(theme_ptr->theme_horizontal_scroll_style, (GX_SCROLLBAR_APPEARANCE *) &theme_ptr->theme_horizontal_scrollbar_appearance);\n"));
    FileWrite(out);

    out.Format(
        _T("        }\n")
        _T("    }\n"));
    FileWrite(out);

    WriteComment("Install the language table.");

    if (project_lib_version() < 50402)
    {
        out.Format(
            _T("    if(display_info->language_table)\n")
            _T("    {\n")
            _T("        gx_system_language_table_set((GX_CHAR ***) display_info->language_table, display_info->language_table_size, display_info->string_table_size);\n")
            _T("        gx_system_active_language_set(language);\n")
            _T("    }\n"));
    }
    else if (project_lib_version() < GX_VERSION_STRING_LENGTH_FIX)
    {
        out.Format(
            _T("    if(display_info->language_table)\n")
            _T("    {\n")
            _T("        gx_display_language_table_set(display_info->display, (GX_CHAR ***) display_info->language_table, (GX_UBYTE) display_info->language_table_size, display_info->string_table_size);\n")
            _T("        gx_display_active_language_set(display_info->display, language);\n")
            _T("    }\n"));
    }
    else
    {
        out.Format(
            _T("    if(display_info->language_table)\n")
            _T("    {\n")
            _T("        gx_display_language_table_set_ext(display_info->display, display_info->language_table, (GX_UBYTE) display_info->language_table_size, display_info->string_table_size);\n")
            _T("        gx_display_active_language_set(display_info->display, language);\n")
            _T("    }\n"));
    }

    FileWrite(out);

    if (string_table::TestGenerateLanguageDirectionTable())
    {
        WriteComment("Install the language direction table.");

        out.Format(
            _T("    if(display_info->language_direction_table)\n")
            _T("    {\n")
            _T("        gx_display_language_direction_table_set(display_info->display, display_info->language_direction_table, (GX_UBYTE) display_info->language_table_size);\n")
            _T("    }\n"));

        FileWrite(out);
    }

    if (project_lib_version() >= GX_VERSION_DISPLAY_ROTATION)
    {
        WriteComment("Set screen rotation angle.");
        out = _T("    display_info->display->gx_display_rotation_angle = display_info->rotation_angle;");
        FileWrite(out);
    }

    out.Format(_T("\n\n")
        _T("/* create the canvas for this display */\n\n")
        _T("    gx_canvas_create(display_info->canvas,\n")
        _T("                     display_info->canvas_name,\n")
        _T("                     display_info->display,\n")
        _T("                     GX_CANVAS_MANAGED | GX_CANVAS_VISIBLE,\n")
        _T("                     display_info->x_resolution,\n")
        _T("                     display_info->y_resolution,\n")
        _T("                     display_info->canvas_memory,\n")
        _T("                     display_info->canvas_memory_size);\n"));
    FileWrite(out);

    WriteComment("Create the root window for this canvas");

    FileWrite(CString("    gx_utility_rectangle_define(&size,\n"
        "                                0, 0,\n"
        "                                (GX_VALUE) (display_info->x_resolution - 1),\n"
        "                                (GX_VALUE) (display_info->y_resolution - 1));\n"));
    out.Format(_T("\n")
        _T("    gx_window_root_create(display_info->root_window,\n")
        _T("                          display_info->name,\n")
        _T("                          display_info->canvas, GX_STYLE_NONE, 0, &size);\n")
        _T("    if (return_root)\n")
        _T("    {\n")
        _T("        *return_root = display_info->root_window;\n")
        _T("    }\n")
        _T("    return GX_SUCCESS;\n")
        _T("}\n"));
    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
BOOL screen_generator::CheckDependencies(widget_info *info, BOOL top_level) const
{
    CString upper_name;
    CString check_name;

    while(info)
    {
        if (info->basetype == GX_TYPE_TEMPLATE)
        {
            template_service_provider *tp = (template_service_provider *) widget_factory::GetServiceProvider(GX_TYPE_TEMPLATE);
            widget_info *base_info = tp->GetBaseInfo(info);

            if (!base_info)
            {
                ErrorMsg("Internal Error: Could not locate template base");
                return TRUE;
            }

            if (GetProjectView() && GetProjectView()->IsTopLevelWidget(base_info))
            {
                check_name = m_screen_name_prefix + base_info->app_name;
            }
            else
            {
                check_name = base_info->app_name;
            }

            if (!IsItemInArray<CString>(name_list, check_name))
            {
                // can't write this one out yet, base is not written
                return FALSE; 
            }
        }
        if (info->GetChildWidgetInfo())
        {
            if (!CheckDependencies(info->GetChildWidgetInfo()))
            {
                return FALSE;
            }
        }
        if (top_level)
        {
            return TRUE;            
        }
        else
        {
            info = info->GetNextWidgetInfo();
        }
    }
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
bool screen_generator::SetOutFile(CString &requested_file)
{
    CString pathname;
    CString outfile;
    PATHINFO info;
    int display;
    CFile *testfile;

    if (requested_file.IsEmpty())
    {
        if (output_file_list.GetCount() != 0)
        {
            m_outfile = output_file_list.GetAt(0);
            return TRUE;
        }
        else
        {
            ErrorMsg("Internal error: Invalid output file request.");
            return FALSE;
        }
    }
    else
    {
        outfile = m_output_filepath + requested_file + _T(".c");        /* output_file_list not 0 means we are specifying output for folders.*/

        if (output_file_list.GetCount() != 0)
        {
            CCommandInfo *pCmdInfo = GetCmdInfo();

            if (!pCmdInfo->GetSpecificationFileName().IsEmpty())
            {
                outfile = requested_file;
                outfile += CString("_") + pCmdInfo->GetSpecificationFileName();
                outfile = m_output_filepath + outfile + _T(".c");        /* output_file_list not 0 means we are specifying output for folders.*/
            }
        }
    }

    if (outfile.GetAt(1) != ':')
    {

        ConvertToProjectRelativePath(outfile);

        info.pathname = outfile;
        info.pathtype = PATH_TYPE_PROJECT_RELATIVE;
        outfile = MakeAbsolutePathname(info);
    }

    for (int index = 0; index < output_file_list.GetCount(); index++)
    {
        testfile = output_file_list.GetAt(index);

        pathname = testfile->GetFilePath();

        if (!outfile.Compare(pathname))
        {
            m_outfile = testfile;
            return TRUE;
        }
    }

    if (!CheckOutputFileSecurity(outfile))
    {
        return FALSE;
    }

    testfile = new CFile();
    if (!testfile->Open(outfile, CFile::modeCreate | CFile::modeWrite))
    {
        CString msg;
        msg.Format(_T("Could not open output file:\n%s\nPlease check resource file path."), outfile);
        ErrorMsg(msg);
        delete testfile;
        return FALSE;
    }
    output_file_list.Add(testfile);
    m_outfile = testfile;

    WriteCommentBlock(SourceHeaderCommentStart);
    CString out;
    out.Format(_T("#define GUIX_STUDIO_GENERATED_FILE\n"));
    FileWrite(out);

    if (m_project->mHeader.insert_headers_before)
    {
        //Include additional headers
        WriteAdditionalHeaders(m_project->mHeader.additional_headers);
    }

    out.Format(_T("#include <stddef.h>\n"));
    FileWrite(out);

    if (m_project->mHeader.num_displays > 1)
    {
        for (display = 0; display < m_project->mHeader.num_displays; display++)
        {
            // primary specs needs all resources for display table
            out.Format(_T("#include \"%s_%s_resources.h\"\n"), m_project->mHeader.project_name, m_project->mDisplays[display].name);
            FileWrite(out);
        }
    }
    else
    {
        out.Format(_T("#include \"%s_resources.h\"\n"), m_project->mHeader.project_name);
        FileWrite(out);
    }
    out.Format(_T("#include \"%s_specifications.h\"\n"), m_project->mHeader.project_name);
    FileWrite(out);

    if (!m_project->mHeader.insert_headers_before)
    {
        //Include additional headers
        WriteAdditionalHeaders(m_project->mHeader.additional_headers);
    }

    FileWrite(CString("\n"));

    if (m_outfile == output_file_list.GetAt(0))
    {
        out = _T("static GX_WIDGET *gx_studio_nested_widget_create(GX_BYTE *control, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent);\n");
        FileWrite(out);
    }
    else
    {
        /* if not default file, extern root window. */
        for (int display = 0; display < m_project->mHeader.num_displays; display++)
        {
            out.Format(_T("extern GX_WINDOW_ROOT %s_root_window;\n"), m_project->mDisplays[display].name);
            FileWrite(out);
        }
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::DeclareDisplayControlBlock()
{
    CString display_name;
    CString out("");

    /* Set output file to the default file: Empty means default output file. */
    SetOutFile(out);

    for (int display = 0; display < m_project->mHeader.num_displays; display++)
    {
        display_name = m_project->mDisplays[display].name;
        out.Format(
            _T("GX_DISPLAY %s_control_block;\n")
            _T("GX_WINDOW_ROOT %s_root_window;\n")
            _T("GX_CANVAS  %s_canvas_control_block;\n"),
            display_name, display_name, display_name);
        FileWrite(out);

        if (m_project->mDisplays[display].allocate_canvas)
        {
            out.Format(_T("ULONG      %s_canvas_memory[%d];\n\n"),
                display_name, (CalculateCanvasSizeBytes(display) / 4));

            FileWrite(out);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
/* Display table and setup define. */
void screen_generator::GenerateDisplayConfigBlock()
{
    WriteDisplayConfigure();

    if (IsCpuWithDave2D(m_project) && m_project->mHeader.guix_version >= 50300)
    {
        WriteComment("Provide display driver setup function");
        for (int display = 0; display < m_project->mHeader.num_displays; display++)
        {
            WriteDave2DSetupFunction(display);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
/* Write widgets properties by folder. */
void screen_generator::WriteWidgetsInfo()
{
    name_list.RemoveAll();

    for (int display = 0; display < m_project->mHeader.num_displays; display++)
    {
        m_project->mDisplays[display].stable->MakeMLViewReferenceRecord(display);
        m_display = display;
        bool completed = FALSE;

        if (m_project->mHeader.num_displays > 1)
        {
            m_screen_name_prefix = m_project->mDisplays[display].name + _T("_");
        }

        while (!completed)
        {
            completed = TRUE;
            folder_info *folder = m_project->mDisplays[display].GetFirstChildFolder();

            while (folder)
            {
                if (SetOutFile(folder->output_filename))
                {
                    widget_info *info = folder->GetFirstChildWidget();

                    while (info)
                    {
                        if (IsItemInArray<CString>(name_list, m_screen_name_prefix + info->app_name))
                        {
                            // already wrote this one out, continue
                            info = info->GetNextWidgetInfo();
                            continue;
                        }

                        if (!CheckDependencies(info, TRUE))
                        {
                            info = info->GetNextWidgetInfo();
                            completed = FALSE;
                            continue;
                        }

                        name_list.Add(m_screen_name_prefix + info->app_name);

                        CString out = m_screen_name_prefix + info->app_name + _T("_");
                        WriteWidgetProperties(out, info, TRUE);

                        WriteChildDefine(m_screen_name_prefix + info->app_name, info->GetChildWidgetInfo());

                        //child definition might be referenced
                        CheckWriteScreenFlow(display, info);

                        WriteParentDefine(info);
                        info = info->GetNextWidgetInfo();
                    }
                }
                folder = folder->GetNextFolder();
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
/* Get base screen to make sure it will be defined or declared before this screen. */
void screen_generator::WriteExternBaseDefines(folder_info *folder)
{
    CFile *default_file = output_file_list.GetAt(0);

    if (!default_file)
    {
        return;
    }

    CString default_filename = default_file->GetFileName();
    CString base_ofilename;
    CString derived_ofilename;

    widget_info *base;
    folder_info *base_folder;
    CString out;
    CString name;

    widget_info *screen = folder->GetFirstChildWidget();

    while (screen)
    {
        if (screen->basetype == GX_TYPE_TEMPLATE)
        {
            base = GetOpenProject()->FindWidgetInfo(folder, screen->base_name, FALSE);
            base_folder = GetOpenProject()->FindParentFolderInfo(base);
            
            if (base_folder)
            {
                if (base_folder->output_filename.IsEmpty())
                {
                    base_ofilename = default_filename;
                }
                else
                {
                    base_ofilename = base_folder->output_filename + _T(".c");
                }

                derived_ofilename = folder->output_filename + _T(".c");

                if (base_ofilename != derived_ofilename)
                {
                    // extern base that has different output filename than
                    // the derived widget
                    name.Format(_T("%s%s"), m_screen_name_prefix, screen->base_name);

                    if (!IsItemInArray<CString>(name_list, name))
                    {
                        out.Format(_T("extern GX_CONST GX_STUDIO_WIDGET %s_define;\n"), name);
                        FileWrite(out);

                        name_list.Add(name);
                    }
                }
            }

        }
        screen = screen->GetNextWidgetInfo();
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteExternBaseDefines()
{
    BOOL completed = FALSE;
    CString current_output_filename;
    CArray<folder_info *> folder_list;

    m_screen_name_prefix = _T("");

    CFile *default_file = output_file_list.GetAt(0);
    if (!default_file)
    {
        return;
    }

    CString default_filename = default_file->GetFileName();
    CString custom_filename;

    while (!completed)
    {
        completed = TRUE;
        name_list.RemoveAll();
        current_output_filename.Empty();

        for (int display = 0; display < m_project->mHeader.num_displays; display++)
        {
            if (m_project->mHeader.num_displays > 1)
            {
                m_screen_name_prefix = m_project->mDisplays[display].name + _T("_");
            }

            folder_info *folder = m_project->mDisplays[display].GetFirstChildFolder();

            while (folder)
            {
                if (folder->output_filename.IsEmpty())
                {
                    custom_filename = default_filename;
                }
                else
                {
                    custom_filename = folder->output_filename + _T(".c");
                }

                if (custom_filename != default_filename &&
                    !IsItemInArray<folder_info *>(folder_list, folder))
                {
                    if (current_output_filename.IsEmpty())

                    {
                        current_output_filename = folder->output_filename;
                        SetOutFile(folder->output_filename);
                    }

                    if (folder->output_filename == current_output_filename)
                    {
                        WriteExternBaseDefines(folder);
                        folder_list.Add(folder);
                    }
                    else
                    {
                        completed = FALSE;
                    }
                }

                folder = folder->GetNextFolder();
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::GenerateScreenSource()
{
    // declare control blocks
    DeclareControlBlocks();

    // extern base defines that has been referenced
    WriteExternBaseDefines();
    
    // Declare canvas and display.
    DeclareDisplayControlBlock();

    // Write extern widgets to the default output file
    WriteExternWidgetsToDefaultFile();

    DeclareDisplayTable();


    /* Write Screen flow functions. */
    /* Write universal function */
    if (ProjectHasScreenFlow())
    {
        /* Write extern screens for screen flow*/
        WriteExternWidgetsUsedByScreenFlow();

        /* Write static auto event functions. */
        WriteAutoEventHandler();
    }

    /* Write generic widget create functions. */
    WriteCreateFunctions();

    /* Write widgets properties. */
    WriteWidgetsInfo();
    
    /* Following should be generated in default file. */
    if (SetOutFile(CString("")))
    {
        DeclareWidgetTable();
        /* Display control block defines. */
        GenerateDisplayConfigBlock();
    }
}


///////////////////////////////////////////////////////////////////////////////
void screen_generator::GenerateAnimationInfoName(flow_item *item, CString &name, int index)
{
    name.Format(_T("%s_animation_%d"), m_screen_name_prefix + item->screen_name, index);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::GenerateAnimationInfo(flow_item *item, trigger_info *trigger, action_info *action, int index)
{
    CString name;
    CString out;
    CString target_name;
    CString parent_name;
    widget_info *target_info = NULL;
    widget_info *parent_info = NULL;
    GX_ANIMATION_INFO *info = action->animation;
    folder_info *folder = m_project->mDisplays[m_display].GetFirstChildFolder();

    if (info)
    {
        GenerateAnimationInfoName(item, name, index);
        out.Format(_T("\nGX_ANIMATION_INFO %s = {\n"), name);
        FileWrite(out);

        target_name = _T("GX_NULL");

        if (action->target_widget_name.GetLength() > 0)
        {
            if (action->target_show_child_widgets)
            {
                //find the top level widget
                target_info = m_project->FindWidgetInfo(folder, item->screen_name, FALSE);

                //search the target widget under the top level widget
                target_info = m_project->FindWidgetInfo(target_info->GetChildWidgetInfo(), action->target_widget_name, TRUE);
            }
            else
            {
                //search the target widget through top level widgets
                target_info = m_project->FindWidgetInfo(folder, action->target_widget_name, FALSE);
            }

            if (target_info)
            {
                if (target_info->allocation == STATICALLY_ALLOCATED)
                {
                    target_name = GetWidgetReferenceName(target_info);
                    target_name = _T("(GX_WIDGET *) &") + m_screen_name_prefix + target_name;
                }
            }
        }

        parent_name = _T("GX_NULL");

        if (action->parent_widget_name.IsEmpty())
        {
            //action parent is not set

            //get the parent of the target widget
            parent_info = m_project->FindParentInfo(target_info);

            if (parent_info)
            {
                //set action parent to target's parent
                if (parent_info->allocation == STATICALLY_ALLOCATED)
                {
                    parent_name = GetWidgetReferenceName(parent_info);
                    parent_name = _T("(GX_WIDGET *) &") + m_screen_name_prefix + parent_name;
                }
            }
            else
            {
                //set action parent to root
                /* See if we can resolve to the root window name */
                parent_name = _T("(GX_WIDGET *) &") + m_project->mDisplays[m_display].name;
                parent_name += "_root_window";
            }
        }
        else
        {
            if (action->parent_show_child_widgets)
            {
                //find the top level widget
                parent_info = m_project->FindWidgetInfo(folder, item->screen_name, FALSE);

                //search the parent widget under the top level widget
                parent_info = m_project->FindWidgetInfo(parent_info->GetChildWidgetInfo(), action->parent_widget_name, TRUE);
            }
            else
            {
                //search the parent widget through top level widgets
                parent_info = m_project->FindWidgetInfo(folder, action->parent_widget_name, FALSE);
            }

            if (parent_info)
            {
                if (parent_info->allocation == STATICALLY_ALLOCATED)
                {
                    parent_name = GetWidgetReferenceName(parent_info);
                    parent_name = _T("(GX_WIDGET *) &") + m_screen_name_prefix + parent_name;
                }
            }
        }

        CString animation_id_name("0");
        CString animation_style_string("0");

        if (!action->animation_id_name.IsEmpty())
        {
            animation_id_name = action->animation_id_name;
        }

        GetAnimationStyles(info, animation_style_string);

/*
    GX_WIDGET  *gx_animation_target;
    GX_WIDGET  *gx_animation_parent;
    GX_WIDGET **gx_animation_slide_screen_list;
    USHORT      gx_animation_style;
    USHORT      gx_animation_id;
    USHORT      gx_animation_delay_before;
    USHORT      gx_animation_tick_rate;
    GX_POINT    gx_animation_start_position;
    GX_POINT    gx_animation_end_position;
    GX_UBYTE    gx_animation_start_alpha;
    GX_UBYTE    gx_animation_end_alpha;
    GX_UBYTE    gx_animation_steps;

*/

        out.Format(_T("    %s,\n")  // target
                   _T("    %s,\n")  // parent
                   _T("    GX_NULL,\n") // screen_list
                   _T("    %s, %s, %d, %d,\n") // animation style, animation id, delay before, delay
                   _T("    {%d, %d}, {%d, %d}, %d, %d, %d\n") // start pos, end pos, start alpha, end_alpha, steps
                   _T("};\n\n"),

            target_name,
            parent_name,
            animation_style_string,
            animation_id_name,
            info->gx_animation_start_delay,
            info->gx_animation_frame_interval,
            info->gx_animation_start_position.gx_point_x,
            info->gx_animation_start_position.gx_point_y,
            info->gx_animation_end_position.gx_point_x,
            info->gx_animation_end_position.gx_point_y,
            info->gx_animation_start_alpha,
            info->gx_animation_end_alpha,
            info->gx_animation_steps);

        FileWrite(out);
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::GenerateActionListName(flow_item *item, trigger_info *trigger, CString &name)
{
    CString trigger_name_as_c = trigger->trigger_name;
    trigger_name_as_c.Remove(' ');
    trigger_name_as_c.Replace(_T("on_gx_signal"), _T(""));
    trigger_name_as_c.Replace(',', '_');
    trigger_name_as_c.Replace('(', '_');
    trigger_name_as_c.Replace(')', '_');
    trigger_name_as_c.Replace(_T("__"), _T("_"));
    name.Format(_T("%s_%sactions"), m_screen_name_prefix + item->screen_name, trigger_name_as_c);
}



///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteAutoEventHandler()
{
CString out("");

    /* Set output file to the default file: Empty means default output file. */
    SetOutFile(out);

    out = "static GX_WIDGET *gx_studio_action_target_get(GX_WIDGET *current, GX_CONST GX_STUDIO_ACTION *action)\n"
          "{\n"
          "    GX_WIDGET *parent = GX_NULL;\n"
          "    GX_WIDGET *target = GX_NULL;\n"
          "    INT        search_depth;\n"
          "    GX_STUDIO_WIDGET *widget_define;\n\n"
          "    if (action->flags & GX_ACTION_FLAG_DYNAMIC_TARGET)\n"
          "    {\n"
          "        /* dynamically create the target widget */\n"
          "        widget_define = (GX_STUDIO_WIDGET *) action->target;\n"
          "        if(action->flags & GX_ACTION_FLAG_DYNAMIC_PARENT)\n"
          "        {\n"
          "            gx_window_root_find(current, (GX_WINDOW_ROOT **)&parent);\n"
          "            search_depth = GX_SEARCH_DEPTH_INFINITE;\n"
          "        }\n"
          "        else\n"
          "        {\n"
          "            parent = (GX_WIDGET *)action->parent;\n"
          "            search_depth = 1;\n"
          "        }\n"
          "        gx_widget_find(parent, widget_define->widget_id, search_depth, &target);\n"
          "        if (target == GX_NULL)\n"
          "        {\n"
          "            target = gx_studio_widget_create(GX_NULL, widget_define, GX_NULL);\n"
          "        }\n"
          "        if (target)\n"
          "        {\n"
          "            target->gx_widget_status |= GX_STATUS_STUDIO_CREATED;\n"
          "        }\n"
          "    }\n"
          "    else\n"
          "    {\n"
          "        target = (GX_WIDGET *) action->target;\n"
          "    }\n"
          "    return target;\n"
          "}\n\n";
    FileWrite(out);

    out = "static GX_WIDGET *gx_studio_action_target_find(GX_WIDGET *current, GX_CONST GX_STUDIO_ACTION *action)\n"
          "{\n"
          "    GX_WIDGET *parent = GX_NULL;\n"
          "    GX_WIDGET *target = GX_NULL;\n"
          "    GX_STUDIO_WIDGET *widget_define;\n\n"
          "    if (action->flags & GX_ACTION_FLAG_DYNAMIC_TARGET)\n"
          "    {\n"
          "        /* Find the dynamically created target */\n"
          "        widget_define = (GX_STUDIO_WIDGET *) action->target;\n"
          "        if(action->flags & GX_ACTION_FLAG_DYNAMIC_PARENT)\n"
          "        {\n"
          "            gx_window_root_find(current, (GX_WINDOW_ROOT **)&parent);\n"
          "        }\n"
          "        else\n"
          "        {\n"
          "            parent = (GX_WIDGET *)action->parent;\n"
          "        }\n"
          "        gx_widget_find(parent, widget_define->widget_id, GX_SEARCH_DEPTH_INFINITE, &target);\n"
          "    }\n"
          "    else\n"
          "    {\n"
          "        target = (GX_WIDGET *) action->target;\n"
          "    }\n"
          "    return target;\n"
          "}\n\n";
    FileWrite(out);

    out = "static GX_WIDGET *gx_studio_action_parent_find(GX_WIDGET *current, GX_CONST GX_STUDIO_ACTION *action)\n"
          "{\n"
          "GX_WIDGET *parent = GX_NULL;\n"
          "GX_STUDIO_WIDGET *widget_define;\n\n"
          "    if (action->flags & GX_ACTION_FLAG_DYNAMIC_PARENT)\n"
          "    {\n"
          "        /* Find the dynamically created target */\n"
          "        widget_define = (GX_STUDIO_WIDGET *)action->parent; \n"
          "        gx_window_root_find(current, (GX_WINDOW_ROOT **)&parent); \n"
          "        gx_widget_find(parent, widget_define->widget_id, GX_SEARCH_DEPTH_INFINITE, &parent); \n"
          "    }\n"
          "    else\n"
          "    {\n"
          "        parent = (GX_WIDGET *)action->parent; \n"
          "    }\n"
          "    return parent; \n"
          "}\n\n";
    FileWrite(out);

    out =  "static VOID gx_studio_animation_execute(GX_WIDGET *current, GX_CONST GX_STUDIO_ACTION *action)\n"
           "{\n"
           "    GX_ANIMATION *animation;\n"
           "    GX_ANIMATION_INFO animation_info;\n";
    if (project_lib_version() > 50402)
    {

        out +=
           "    GX_WIDGET *parent = GX_NULL;\n";
    }
    out +=
           "    GX_WIDGET *target = GX_NULL;\n"
           "    gx_system_animation_get(&animation);\n"
           "    if (animation)\n"
           "    {\n"
           "        animation_info = *action->animation;\n\n";
    if (project_lib_version() > 50402)
    {
        out +=
           "        if((action->flags & GX_ACTION_FLAG_POP_TARGET) ||\n"
           "           (action->flags & GX_ACTION_FLAG_POP_PARENT))\n"
           "        {\n"
           "            gx_system_screen_stack_get((GX_WIDGET **)&parent, &target);\n"
           "        }\n\n"
           "        if(action->flags & GX_ACTION_FLAG_POP_TARGET)\n"
           "        {\n"
           "            animation_info.gx_animation_target = target;\n"
           "        }\n\n"
           "        if(action->flags & GX_ACTION_FLAG_POP_PARENT)\n"
           "        {\n"
           "            animation_info.gx_animation_parent = (GX_WIDGET *)parent;\n"
           "        }\n\n";
    }

    out +=
           "        if ((!animation_info.gx_animation_target) &&\n"
           "            (action->flags & GX_ACTION_FLAG_DYNAMIC_TARGET))\n"
           "        {\n"
           "            target = gx_studio_action_target_get(current, action);\n"
           "            animation_info.gx_animation_target = target;\n"
           "        }\n\n"
           "        if (!animation_info.gx_animation_parent)\n"
           "        {\n"
           "            animation_info.gx_animation_parent = gx_studio_action_parent_find(current, action);\n"
           "        }\n\n"
           "        if (animation_info.gx_animation_target &&\n"
           "            animation_info.gx_animation_parent)\n"
           "        {\n"
           "            gx_animation_start(animation, &animation_info);\n"
           "        }\n"
           "    }\n"
           "}\n\n";
    FileWrite(out);

    out = "UINT gx_studio_auto_event_handler(GX_WIDGET *widget, GX_EVENT *event_ptr, GX_CONST GX_STUDIO_EVENT_PROCESS *record)\n"
          "{\n"
          "    UINT status = GX_SUCCESS;\n"
          "    GX_CONST GX_STUDIO_ACTION *action;\n"
          "    GX_CONST GX_WIDGET *parent = GX_NULL;\n"
          "    GX_WIDGET *target = GX_NULL;\n"
          "    GX_CONST GX_STUDIO_EVENT_ENTRY *entry = record->event_table;\n\n"
          "    while(entry->event_type)\n"
          "    {\n"
          "        if (entry->event_type == event_ptr->gx_event_type)\n"
          "        {\n"
          "            if((entry->event_type == GX_EVENT_ANIMATION_COMPLETE) &&\n"
          "               (entry->event_sender != event_ptr->gx_event_sender))\n"
          "            {\n"
          "                entry++;\n"
          "                continue;\n"
          "            }\n"
          "            action = entry->action_list;\n\n"
          "            while(action->opcode)\n"
          "            {\n"
          "                switch(action->opcode)\n"
          "                {\n";

    if (project_lib_version() <= 50402)
    {
        out +=
          "                case GX_ACTION_TYPE_ATTACH:\n"
          "                    parent = action->parent;\n"
          "                    target = gx_studio_action_target_get(widget, action);\n"
          "                    if (parent && target)\n"
          "                    {\n"
          "                        gx_widget_attach(parent, target);\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_DETACH:\n"
          "                    target = gx_studio_action_target_find(widget, action);\n"
          "                    if (target)\n"
          "                    {\n"
          "                        gx_widget_detach(target);\n"
          "                        if (target->gx_widget_status & GX_STATUS_STUDIO_CREATED)\n"
          "                        {\n"
          "                            if (widget == target)\n"
          "                            {\n"
          "                                widget = GX_NULL;\n"
          "                            }\n\n"
          "                            gx_widget_delete(target);\n"
          "                        }\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_TOGGLE:\n"
          "                    target = gx_studio_action_target_get(widget, action);\n"
          "                    parent = widget->gx_widget_parent;\n"
          "                    if (parent)\n"
          "                    {\n"
          "                        gx_widget_detach(widget);\n"
          "                        gx_widget_attach(parent, target);\n"
          "                        if (widget->gx_widget_status & GX_STATUS_STUDIO_CREATED)\n"
          "                        {\n"
          "                            gx_widget_delete(widget);\n"
          "                            widget = GX_NULL;\n"
          "                        }\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_SHOW:\n"
          "                    target = gx_studio_action_target_get(widget, action);\n"
          "                    if(target)\n"
          "                    {\n"
          "                        gx_widget_show(target);\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_HIDE:\n"
          "                    target = gx_studio_action_target_find(widget, action);\n"
          "                    if(target)\n"
          "                    {\n"
          "                        gx_widget_hide(target);\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_ANIMATION:\n"
          "                    gx_studio_animation_execute(widget, action);\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_WINDOW_EXECUTE:\n"
          "                    parent = widget->gx_widget_parent;\n"
          "                    target = gx_studio_action_target_get(widget, action);\n"
          "                    if (parent && target)\n"
          "                    {\n"
          "                        gx_widget_attach(parent, target);\n"
          "                        gx_window_execute((GX_WINDOW *) target, GX_NULL);\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_WINDOW_EXECUTE_STOP:\n"
          "                    return event_ptr->gx_event_sender;\n\n";
    }
    else
    {
        out +=
          "                case GX_ACTION_TYPE_ATTACH:\n"
          "                    if((action->flags & GX_ACTION_FLAG_POP_TARGET) ||\n"
          "                       (action->flags & GX_ACTION_FLAG_POP_PARENT))\n"
          "                    {\n"
          "                        gx_system_screen_stack_get((GX_WIDGET **)&parent, &target);\n"
          "                    }\n\n"
          "                    if(!(action->flags & GX_ACTION_FLAG_POP_PARENT))\n"
          "                    {\n"
          "                        parent = action->parent;\n"
          "                    }\n"
          "                    if(!(action->flags & GX_ACTION_FLAG_POP_TARGET))\n"
          "                    {\n"
          "                        target = gx_studio_action_target_get(widget, action);\n"
          "                    }\n"
          "                    if (parent && target)\n"
          "                    {\n"
          "                        gx_widget_attach(parent, target);\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_DETACH:\n"
          "                    target = gx_studio_action_target_find(widget, action);\n"
          "                    if (target)\n"
          "                    {\n"
          "                        gx_widget_detach(target);\n"
          "                        if (target->gx_widget_status & GX_STATUS_STUDIO_CREATED)\n"
          "                        {\n"
          "                            if (widget == target)\n"
          "                            {\n"
          "                                widget = GX_NULL;\n"
          "                            }\n\n"
          "                            gx_widget_delete(target);\n"
          "                        }\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_TOGGLE:\n"
          "                    if(action->flags & GX_ACTION_FLAG_POP_TARGET)\n"
          "                    {\n"
          "                       gx_system_screen_stack_get(GX_NULL, &target);\n"
          "                    }\n"
          "                    else\n"
          "                    {\n"
          "                        target = gx_studio_action_target_get(widget, action);\n"
          "                    }\n"
          "                    parent = widget->gx_widget_parent;\n"
          "                    if (parent)\n"
          "                    {\n"
          "                        gx_widget_detach(widget);\n"
          "                        gx_widget_attach(parent, target);\n"
          "                        if (widget->gx_widget_status & GX_STATUS_STUDIO_CREATED)\n"
          "                        {\n"
          "                            gx_widget_delete(widget);\n"
          "                            widget = GX_NULL;\n"
          "                        }\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_SHOW:\n"
          "                    target = gx_studio_action_target_get(widget, action);\n"
          "                    if(target)\n"
          "                    {\n"
          "                        gx_widget_show(target);\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_HIDE:\n"
          "                    target = gx_studio_action_target_find(widget, action);\n"
          "                    if(target)\n"
          "                    {\n"
          "                        gx_widget_hide(target);\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_ANIMATION:\n"
          "                    gx_studio_animation_execute(widget, action);\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_WINDOW_EXECUTE:\n"
          "                    if((action->flags & GX_ACTION_FLAG_POP_TARGET) ||\n"
          "                       (action->flags & GX_ACTION_FLAG_POP_PARENT))\n"
          "                    {\n"
          "                        gx_system_screen_stack_get((GX_WIDGET **)&parent, &target);\n"
          "                    }\n\n"
          "                    if(!(action->flags & GX_ACTION_FLAG_POP_PARENT))\n"
          "                    {\n"
          "                        parent = widget->gx_widget_parent;\n"
          "                    }\n"
          "                    if(!(action->flags & GX_ACTION_FLAG_POP_TARGET))\n"
          "                    {\n"
          "                        target = gx_studio_action_target_get(widget, action);\n"
          "                    }\n"
          "                    if (parent && target)\n"
          "                    {\n"
          "                        gx_widget_attach(parent, target);\n"
          "                        gx_window_execute((GX_WINDOW *) target, GX_NULL);\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_WINDOW_EXECUTE_STOP:\n"
          "                    return event_ptr->gx_event_sender;\n\n"
          "                case GX_ACTION_TYPE_SCREEN_STACK_PUSH:\n"
          "                    target = gx_studio_action_target_get(widget, action);\n"
          "                    if(target)\n"
          "                    {\n"
          "                        gx_system_screen_stack_push(target);\n"
          "                    }\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_SCREEN_STACK_POP:\n"
          "                    gx_system_screen_stack_pop();\n"
          "                    break;\n\n"
          "                case GX_ACTION_TYPE_SCREEN_STACK_RESET:\n"
          "                    gx_system_screen_stack_reset();\n"
          "                    break;\n\n";
    }
    out +=
          "                default:\n"
          "                    break;\n"
          "                }\n"
          "                action++;\n"
          "            }\n"
          "        }\n"
          "        entry++;\n"
          "    }\n\n"

          "    if (widget && record->chain_event_handler)\n"
          "    {\n"
          "        status = record->chain_event_handler(widget, event_ptr);\n"
          "    }\n"
          "    return status;\n"
          "}\n\n";
    FileWrite(out);
}


///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteEventTable(flow_item *item)
{
    CString out;
    CString action_name;
    CString list_name;
    CString trigger_animation_id;

    out.Format(_T("static GX_STUDIO_EVENT_ENTRY gx_studio_%s_event_table[] = {\n"), m_screen_name_prefix + item->screen_name);
    FileWrite(out);

    trigger_info *trigger = item->trigger_list;
    while(trigger)
    {
        GenerateActionListName(item, trigger, list_name);
        if (trigger->system_event_animat_id_name.IsEmpty())
        {
            trigger_animation_id = _T("0");
        }
        else
        {
            trigger_animation_id = trigger->system_event_animat_id_name;
        }

        switch(trigger->trigger_type)
        {
        case TRIGGER_TYPE_SYSTEM_EVENT:
            out.Format(_T("    { %s, %s, %s},\n"),
                trigger_edit_dlg::GetEventTypeName(trigger->event_type),
                trigger_animation_id,
                list_name);
            FileWrite(out);
            break;

        case TRIGGER_TYPE_CHILD_SIGNAL:
            out.Format(_T("    {GX_SIGNAL(%s, %s), %s, %s},\n"), trigger->signal_id_name,
                trigger_edit_dlg::GetEventTypeName(trigger->event_type),
                trigger_animation_id,
                list_name);
            FileWrite(out);
            break;

        case TRIGGER_TYPE_USER_EVENT:
            out.Format(_T("    { %s, %s, %s},\n"),
                trigger->user_event_id_name,
                trigger_animation_id,
                list_name);
            FileWrite(out);
            break;
        }

        trigger = trigger->next;
    }

    FileWrite(CString("    {0, 0, GX_NULL}\n};\n\n"));
};

///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetTempateEventFuncName(widget_info *info)
{
    widget_info *base_info = info;
    widget_info *derived;

    while (base_info->basetype == GX_TYPE_TEMPLATE)
    {
        derived = base_info;
        base_info = template_service_provider::GetBaseInfo(derived);
        if (base_info)
        {
            if (!base_info->event_func.IsEmpty())
            {
                return base_info->event_func;
            }
        }
    }

    return widget_service_provider::GetDefaultEventProcess(base_info->basetype);
}

///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetWidgetReferenceName(widget_info *info)
{
    project_view *project_view = GetProjectView();
    CString name("");

    if (project_view)
    {
        widget_info *parent_info = project_view->FindTopLevelWidget(info);
        if (parent_info && parent_info != info)
        {
            name.Format(_T("%s.%s_%s"), parent_info->app_name, parent_info->app_name, info->app_name);
        }
        else
        {
            name = info->app_name;
        }
    }
    return name;
}

///////////////////////////////////////////////////////////////////////////////
BOOL screen_generator::CheckWriteScreenFlow(int display, widget_info *info)
{
    flow_item *item;
    trigger_info *trigger;
    action_info *action;
    widget_info *target_info;
    widget_info *parent_info;
    int action_count;
    int action_index;
    int animation_index;
    CString out;
    CString action_list_name;

    screen_flow *flow = m_project->mDisplays[display].screenflow;
    folder_info *folder = m_project->mDisplays[display].GetFirstChildFolder();

    if (!flow)
    {
        return FALSE;
    }
    item = flow->GetFlowItem(info->app_name);

    if (!item)
    {
        return FALSE;
    }

    // generate animation info for any actions that have animation
    trigger = item->trigger_list;

    if (!trigger)
    {
        return FALSE;
    }

    animation_index = 1;

    while(trigger)
    {
        action_count = trigger->action_list.GetCount();

        for (action_index = 0; action_index < action_count; action_index++)
        {
            action = trigger->action_list[action_index];
                    
            if (action->animation)
            {
                GenerateAnimationInfo(item, trigger, action, animation_index);
                animation_index++;
            }
        }
        trigger = trigger->next;
    }

    // now generate the action array for each trigger:
    trigger = item->trigger_list;
    animation_index = 1;

    while(trigger)
    {
        GenerateActionListName(item, trigger, action_list_name);
        out.Format(_T("\nGX_STUDIO_ACTION %s[%d] = {\n"),
            action_list_name, trigger->action_list.GetCount() + 1);
        FileWrite(out);

        action_count = trigger->action_list.GetCount();

        for (action_index = 0; action_index < action_count; action_index++)
        {
            action = trigger->action_list[action_index];
            CString parent_name(_T("GX_NULL"));
            CString target_name(parent_name);
            CString animation_name(parent_name);
            CString action_name;
            CString action_flags(_T("0"));

            //search target widget info
            if (action->target_widget_name.IsEmpty())
            {
                target_info = NULL;
            }
            else if (action->target_widget_name == SCREEN_STACK_POP_STRING)
            {
                //get target from screen stack
                target_info = NULL;
                action_flags = "GX_ACTION_FLAG_POP_TARGET";
            }
            else
            {
                if (action->target_show_child_widgets)
                {
                    target_info = m_project->FindWidgetInfo(folder, item->screen_name, FALSE);
                    target_info = m_project->FindWidgetInfo(target_info->GetChildWidgetInfo(), action->target_widget_name, TRUE);
                }
                else
                {
                    target_info = m_project->FindWidgetInfo(folder, action->target_widget_name, FALSE);
                }
            }

            if (action->parent_widget_name.IsEmpty())
            {
                if (target_info)
                {
                    parent_info = m_project->FindParentInfo(target_info);
                }
                else
                {
                    parent_info = NULL;
                }
                
                if (!parent_info)
                {
                    /* See if we can resolve to the root window name */
                    parent_name = _T("&") + m_project->mDisplays[m_display].name + _T("_root_window");
                }
            }
            else if (action->parent_widget_name == SCREEN_STACK_POP_STRING)
            {
                //get parent from screen stack
                parent_info = GX_NULL;
                if (action_flags == "0")
                {
                    action_flags = "GX_ACTION_FLAG_POP_PARENT";
                }
                else
                {
                    action_flags += "|GX_ACTION_FLAG_POP_PARENT";
                }
                
            }
            else
            {
                if (action->parent_show_child_widgets)
                {
                    //find the top level widget
                    parent_info = m_project->FindWidgetInfo(folder, item->screen_name, FALSE);

                    //search the parent widget under the top level widget
                    parent_info = m_project->FindWidgetInfo(parent_info->GetChildWidgetInfo(), action->parent_widget_name, TRUE);
                }
                else
                {
                    //search the parent widget through top level widgets
                    parent_info = m_project->FindWidgetInfo(folder, action->parent_widget_name, FALSE);
                }
            }

            if (parent_info)
            {
                parent_name = GetWidgetReferenceName(parent_info);

                if (parent_info->allocation == STATICALLY_ALLOCATED)
                {
                    parent_name = _T("&") + m_screen_name_prefix + parent_name;
                }
                else
                {
                    int index = parent_name.Find('.');
                    parent_name = parent_name.Mid(index + 1);
                    if (action_flags == "0")
                    {
                        action_flags = "GX_ACTION_FLAG_DYNAMIC_PARENT";
                    }
                    else
                    {
                        action_flags += "|GX_ACTION_FLAG_DYNAMIC_PARENT";
                    }
                    parent_name = _T(" &") + m_screen_name_prefix + parent_name + _T("_define");
                }
            }

            if (target_info)
            {
                target_name = GetWidgetReferenceName(target_info);

                if (target_info->allocation == STATICALLY_ALLOCATED)
                {
                    target_name = _T("&") + m_screen_name_prefix + target_name;
                }
                else
                {
                    if (action_flags == "0")
                    {
                        action_flags = "GX_ACTION_FLAG_DYNAMIC_TARGET";
                    }
                    else
                    {
                        action_flags += "|GX_ACTION_FLAG_DYNAMIC_TARGET";
                    }

                    int index = target_name.Find('.');
                    target_name = target_name.Mid(index + 1);
                    target_name = _T(" &") + m_screen_name_prefix + target_name + _T("_define");
                }
            }
            if (action->animation)
            {
                GenerateAnimationInfoName(item, animation_name, animation_index);
                animation_name = CString(_T("&")) + animation_name;
                animation_index++;
            }
                    
            action_name = _T("GX_ACTION_TYPE_") + trigger_action_select_dlg::GetActionTypeName(action->action_type).MakeUpper();
            action_name.Replace(' ', '_');

            out.Format(_T("    {%s, %s, %s, %s, %s},\n"),
                action_name, action_flags,
                parent_name, target_name, animation_name);
            FileWrite(out);
        }
        out.Format(_T("    {0, 0, GX_NULL, GX_NULL, GX_NULL}\n};\n\n"));
        FileWrite(out);
        trigger = trigger->next;
    }

    WriteEventTable(item);

    // Generate the event chaining record

    out.Format(_T("GX_STUDIO_EVENT_PROCESS %s_event_chain = {"), m_screen_name_prefix + item->screen_name);
    FileWrite(out);

    out.Format(_T("gx_studio_%s_event_table, "), m_screen_name_prefix + item->screen_name);    
    FileWrite(out);

    CString event_func_name;

    if (info->event_func.IsEmpty())
    {
        if (info->basetype == GX_TYPE_TEMPLATE)
        {
            event_func_name = GetTempateEventFuncName(info);
        }
        else
        {
            event_func_name = widget_service_provider::GetDefaultEventProcess(info->basetype);
        }
    }
    else
    {
        event_func_name = info->event_func;
    }
    out.Format(_T("(UINT (*)(GX_WIDGET *, GX_EVENT *))%s};\n"), event_func_name);
    FileWrite(out);

    /* write out the studio-generated event process function */

    out.Format(_T("static UINT gx_studio_%s_event_process(GX_WIDGET *target, GX_EVENT *event_ptr)\n{\n"), m_screen_name_prefix + item->screen_name);
    FileWrite(out);

    out.Format(_T("    return (gx_studio_auto_event_handler(target, event_ptr, &%s_event_chain));\n}\n\n"), m_screen_name_prefix + item->screen_name);
    FileWrite(out);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL screen_generator::IsTextType(widget_info *info)
{
    BOOL texttype = FALSE;
    switch(info->basetype)
    {
    case GX_TYPE_TEXT_BUTTON:
    case GX_TYPE_MULTI_LINE_TEXT_BUTTON:
    case GX_TYPE_RADIO_BUTTON:
    case GX_TYPE_CHECKBOX:
    case GX_TYPE_PROMPT:
    case GX_TYPE_MENU:
    case GX_TYPE_NUMERIC_PROMPT:
    case GX_TYPE_PIXELMAP_PROMPT:
    case GX_TYPE_NUMERIC_PIXELMAP_PROMPT:
    case GX_TYPE_SINGLE_LINE_TEXT_INPUT:
    //case GX_TYPE_PIXELMAP_TEXT_INPUT:
    case GX_TYPE_MULTI_LINE_TEXT_VIEW:
    case GX_TYPE_MULTI_LINE_TEXT_INPUT:
    case GX_TYPE_RICH_TEXT_VIEW:
    case GX_TYPE_NUMERIC_SCROLL_WHEEL:
    case GX_TYPE_STRING_SCROLL_WHEEL:
        texttype = TRUE;
        break;

    default:
        break;
    }

    return texttype;
}

///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetWidgetTypeName(widget_info *info)
{
    widget_service_provider *provider = widget_factory::GetServiceProvider(info->basetype);

    if (provider)
    {
        return (provider->GetTypeName(info));
    }
    return CString("");
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetType(widget_info *info)
{
    CString type_name = GetWidgetTypeName(info);
    CString out;
    out.Format(_T("    %s,     /* widget type */\n"), type_name);
    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetId(widget_info *info)
{
    CString out;
    if (info->id_name.IsEmpty())
    {
        FileWrite(CString("    GX_ID_NONE,      /* widget id */\n"));
    }
    else
    {
        out.Format(_T("    %s,     /* widget id */\n"), info->id_name);
        FileWrite(out);
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetUserData(widget_info *info)
{
    CString out;
    CString temp;

    out = CString("    #if defined(GX_WIDGET_USER_DATA)\n");

    if (info->user_data.IsEmpty())
    {
        out += "    0,    /* user data */\n";
    }
    else
    {
        temp.Format(_T("    %s,     /* user data */\n"), info->user_data);
        out += temp;
    }
    out += "    #endif\n";
    FileWrite(out);
}


///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddButtonStyles(widget_info *info, CString &out)
{
    if (info->style & GX_STYLE_BUTTON_PUSHED)
    {
        out += CString("|GX_STYLE_BUTTON_PUSHED");
    }
    if (info->style & GX_STYLE_BUTTON_TOGGLE)
    {
        out += CString("|GX_STYLE_BUTTON_TOGGLE");
    }
    if (info->style & GX_STYLE_BUTTON_RADIO)
    {
        out += CString("|GX_STYLE_BUTTON_RADIO");
    }
    if (info->style & GX_STYLE_BUTTON_EVENT_ON_PUSH)
    {
        out += CString("|GX_STYLE_BUTTON_EVENT_ON_PUSH");
    }
    if (info->style & GX_STYLE_BUTTON_REPEAT)
    {
        out += CString("|GX_STYLE_BUTTON_REPEAT");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddButtonAlignmentStyles(widget_info *info, CString &out)
{
    switch(info->style & GX_PIXELMAP_HALIGN_MASK)
    {
    case GX_STYLE_HALIGN_CENTER:
        out += CString("|GX_STYLE_HALIGN_CENTER");
        break;
    case GX_STYLE_HALIGN_LEFT:
        out += CString("|GX_STYLE_HALIGN_LEFT");
        break;
    case GX_STYLE_HALIGN_RIGHT:
        out += CString("|GX_STYLE_HALIGN_RIGHT");
        break;
    }

    switch(info->style & GX_PIXELMAP_VALIGN_MASK)
    {
    case GX_STYLE_VALIGN_CENTER:
        out += CString("|GX_STYLE_VALIGN_CENTER");
        break;
    case GX_STYLE_VALIGN_TOP:
        out += CString("|GX_STYLE_VALIGN_TOP");
        break;
    case GX_STYLE_VALIGN_BOTTOM:
        out += CString("|GX_STYLE_VALIGN_BOTTOM");
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddListStyles(widget_info *info, CString &out)
{
    if (info->style & GX_STYLE_CENTER_SELECTED)
    {
        out += CString("|GX_STYLE_CENTER_SELECTED");
    }
    if (info->style & GX_STYLE_WRAP)
    {
        out += CString("|GX_STYLE_WRAP");
    }
    if (info->style & GX_STYLE_REPEAT_SELECT)
    {
        out += CString("|GX_STYLE_REPEAT_SELECT");
    }
    if (info->style & GX_STYLE_FLICKABLE)
    {
        out += CString("|GX_STYLE_FLICKABLE");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddSliderStyles(widget_info *info, CString &out)
{
    if (info->style & GX_STYLE_SHOW_NEEDLE)
    {
        out += CString("|GX_STYLE_SHOW_NEEDLE");
    }
    if (info->style & GX_STYLE_SHOW_TICKMARKS)
    {
        out += CString("|GX_STYLE_SHOW_TICKMARKS");
    }
    if (info->style & GX_STYLE_SLIDER_VERTICAL)
    {
        out += CString("|GX_STYLE_SLIDER_VERTICAL");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddPixelmapSliderStyles(widget_info *info, CString &out)
{
    if (info->style & GX_STYLE_TILE_BACKGROUND)
    {
        out += CString("|GX_STYLE_TILE_BACKGROUND");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddDropListStyles(widget_info *info, CString &out)
{
    if (info->style & GX_STYLE_TILE_WALLPAPER)
    {
        out += CString("|GX_STYLE_TILE_WALLPAPER");
    }
    if (info->style & GX_STYLE_TILE_BACKGROUND)
    {
       out += CString("|GX_STYLE_TILE_BACKGROUND");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddTextAlignStyle(widget_info *info, CString &out)
{
    switch(info->style & GX_STYLE_TEXT_ALIGNMENT_MASK)
    {
    case GX_STYLE_TEXT_LEFT:
        out += CString("|GX_STYLE_TEXT_LEFT");
        break;

    case GX_STYLE_TEXT_RIGHT:
        out += CString("|GX_STYLE_TEXT_RIGHT");
        break;
    
    case GX_STYLE_TEXT_CENTER:
        out += CString("|GX_STYLE_TEXT_CENTER");
        break;
    }
    if (info->basetype == GX_TYPE_MULTI_LINE_TEXT_VIEW)
    {
        if (info->style & GX_STYLE_VALIGN_CENTER)
        {
            out += CString("|GX_STYLE_VALIGN_CENTER");
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddScrollbarStyles(ULONG style, CString &out)
{
    /* Define Scroll Bar styles.  */
    if (style & GX_STYLE_TILE_BACKGROUND)
    {
        out += CString("|GX_STYLE_TILE_BACKGROUND");
    }
    if (style & GX_SCROLLBAR_RELATIVE_THUMB)
    {
        out += CString("|GX_SCROLLBAR_RELATIVE_THUMB");
    }
    if (style & GX_SCROLLBAR_END_BUTTONS)
    {
        out += CString("|GX_SCROLLBAR_END_BUTTONS");
    }
    if (style & GX_SCROLLBAR_VERTICAL)
    {
        out += CString("|GX_SCROLLBAR_VERTICAL");
    }
    if (style & GX_SCROLLBAR_HORIZONTAL)
    {
        out += CString("|GX_SCROLLBAR_HORIZONTAL");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddScrollbarStyles(widget_info *info, CString &out)
{
    AddScrollbarStyles(info->style, out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddProgressBarStyles(widget_info *info, CString &out)
{
    ULONG style = info->style;

    /* Define Progress Bar styles.  */
    if (style & GX_STYLE_PROGRESS_PERCENT)
    {
        out += CString("|GX_STYLE_PROGRESS_PERCENT");
    }
    if (style & GX_STYLE_PROGRESS_TEXT_DRAW)
    {
        out += CString("|GX_STYLE_PROGRESS_TEXT_DRAW");
    }
    if (style & GX_STYLE_PROGRESS_VERTICAL)
    {
        out += CString("|GX_STYLE_PROGRESS_VERTICAL");
    }
    if (style & GX_STYLE_PROGRESS_SEGMENTED_FILL)
    {
        out += CString("|GX_STYLE_PROGRESS_SEGMENTED_FILL");
    }
    if (style & GX_STYLE_RADIAL_PROGRESS_NO_BACKTRACK)
    {
        out += CString("|GX_STYLE_RADIAL_PROGRESS_NO_BACKTRACK");
    }
    if (style & GX_STYLE_RADIAL_PROGRESS_ALIAS)
    {
        out += CString("|GX_STYLE_RADIAL_PROGRESS_ALIAS");
    }
    if (style & GX_STYLE_RADIAL_PROGRESS_ROUND)
    {
        out += CString("|GX_STYLE_RADIAL_PROGRESS_ROUND");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddSpriteStyles(widget_info *info, CString &out)
{
    ULONG style = info->style;

    /* Define Progress Bar styles.  */
    if (style & GX_STYLE_SPRITE_AUTO)
    {
        out += CString("|GX_STYLE_SPRITE_AUTO");
    }
    if (style & GX_STYLE_SPRITE_LOOP)
    {
        out += CString("|GX_STYLE_SPRITE_LOOP");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddWindowStyles(widget_info *info, CString &out)
{
    /* Define Window styles.  */
    if (info->style & GX_STYLE_TILE_WALLPAPER)
    {
        out += CString("|GX_STYLE_TILE_WALLPAPER");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddTextScrollWheelStyles(widget_info *info, CString &out)
{
    if (info->style & GX_STYLE_WRAP)
    {
        out += CString("|GX_STYLE_WRAP");
    }
    if (info->style & GX_STYLE_TEXT_SCROLL_WHEEL_ROUND)
    {
        out += CString("|GX_STYLE_TEXT_SCROLL_WHEEL_ROUND");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddWidgetScrollWheelStyles(widget_info* info, CString& out)
{
    if (info->style & GX_STYLE_WRAP)
    {
        out += CString("|GX_STYLE_WRAP");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddTreeViewStyles(widget_info *info, CString &out)
{
    if (info->style & GX_STYLE_TREE_VIEW_SHOW_ROOT_LINES)
    {
        out += CString("|GX_STYLE_TREE_VIEW_SHOW_ROOT_LINES");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::AddTextInputStyles(widget_info *info, CString &out)
{
    if (info->style & GX_STYLE_TEXT_INPUT_READONLY)
    {
        out += CString("|GX_STYLE_TEXT_INPUT_READONLY");
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::GetAnimationStyles(GX_ANIMATION_INFO *info, CString &out)
{
    if (info->gx_animation_style | GX_ANIMATION_TRANSLATE)
    {
        out = CString("GX_ANIMATION_TRANSLATE");

        if (info->gx_animation_style & GX_ANIMATION_DETACH)
        {
            out += CString("|GX_ANIMATION_DETACH");
        }

        if (info->gx_animation_style & GX_ANIMATION_PUSH_STACK)
        {
            out += CString("|GX_ANIMATION_PUSH_STACK");
        }

        switch (info->gx_animation_style & GX_ANIMATION_EASING_FUNC_MASK)
        {
        case GX_ANIMATION_BACK_EASE_IN:
            out += CString("|GX_ANIMATION_BACK_EASE_IN");
            break;
        case GX_ANIMATION_BACK_EASE_OUT:
            out += CString("|GX_ANIMATION_BACK_EASE_OUT");
            break;
        case GX_ANIMATION_BACK_EASE_IN_OUT:
            out += CString("|GX_ANIMATION_BACK_EASE_IN_OUT");
            break;
        case GX_ANIMATION_BOUNCE_EASE_IN:
            out += CString("|GX_ANIMATION_BOUNCE_EASE_IN");
            break;
        case GX_ANIMATION_BOUNCE_EASE_OUT:
            out += CString("|GX_ANIMATION_BOUNCE_EASE_OUT");
            break;
        case GX_ANIMATION_BOUNCE_EASE_IN_OUT:
            out += CString("|GX_ANIMATION_BOUNCE_EASE_IN_OUT");
            break;
        case GX_ANIMATION_CIRC_EASE_IN:
            out += CString("|GX_ANIMATION_CIRC_EASE_IN");
            break;
        case GX_ANIMATION_CIRC_EASE_OUT:
            out += CString("|GX_ANIMATION_CIRC_EASE_OUT");
            break;
        case GX_ANIMATION_CIRC_EASE_IN_OUT:
            out += CString("|GX_ANIMATION_CIRC_EASE_IN_OUT");
            break;
        case GX_ANIMATION_CUBIC_EASE_IN:
            out += CString("|GX_ANIMATION_CUBIC_EASE_IN");
            break;
        case GX_ANIMATION_CUBIC_EASE_OUT:
            out += CString("|GX_ANIMATION_CUBIC_EASE_OUT");
            break;
        case GX_ANIMATION_CUBIC_EASE_IN_OUT:
            out += CString("|GX_ANIMATION_CUBIC_EASE_IN_OUT");
            break;
        case GX_ANIMATION_ELASTIC_EASE_IN:
            out += CString("|GX_ANIMATION_ELASTIC_EASE_IN");
            break;
        case GX_ANIMATION_ELASTIC_EASE_OUT:
            out += CString("|GX_ANIMATION_ELASTIC_EASE_OUT");
            break;
        case GX_ANIMATION_ELASTIC_EASE_IN_OUT:
            out += CString("|GX_ANIMATION_ELASTIC_EASE_IN_OUT");
            break;
        case GX_ANIMATION_EXPO_EASE_IN:
            out += CString("|GX_ANIMATION_EXPO_EASE_IN");
            break;
        case GX_ANIMATION_EXPO_EASE_OUT:
            out += CString("|GX_ANIMATION_EXPO_EASE_OUT");
            break;
        case GX_ANIMATION_EXPO_EASE_IN_OUT:
            out += CString("|GX_ANIMATION_EXPO_EASE_IN_OUT");
            break;
        case GX_ANIMATION_QUAD_EASE_IN:
            out += CString("|GX_ANIMATION_QUAD_EASE_IN");
            break;
        case GX_ANIMATION_QUAD_EASE_OUT:
            out += CString("|GX_ANIMATION_QUAD_EASE_OUT");
            break;
        case GX_ANIMATION_QUAD_EASE_IN_OUT:
            out += CString("|GX_ANIMATION_QUAD_EASE_IN_OUT");
            break;
        case GX_ANIMATION_QUART_EASE_IN:
            out += CString("|GX_ANIMATION_QUART_EASE_IN");
            break;
        case GX_ANIMATION_QUART_EASE_OUT:
            out += CString("|GX_ANIMATION_QUART_EASE_OUT");
            break;
        case GX_ANIMATION_QUART_EASE_IN_OUT:
            out += CString("|GX_ANIMATION_QUART_EASE_IN_OUT");
            break;
        case GX_ANIMATION_QUINT_EASE_IN:
            out += CString("|GX_ANIMATION_QUINT_EASE_IN");
            break;
        case GX_ANIMATION_QUINT_EASE_OUT:
            out += CString("|GX_ANIMATION_QUINT_EASE_OUT");
            break;
        case GX_ANIMATION_QUINT_EASE_IN_OUT:
            out += CString("|GX_ANIMATION_QUINT_EASE_IN_OUT");
            break;
        case GX_ANIMATION_SINE_EASE_IN:
            out += CString("|GX_ANIMATION_SINE_EASE_IN");
            break;
        case GX_ANIMATION_SINE_EASE_OUT:
            out += CString("|GX_ANIMATION_SINE_EASE_OUT");
            break;
        case GX_ANIMATION_SINE_EASE_IN_OUT:
            out += CString("|GX_ANIMATION_SINE_EASE_IN_OUT");
            break;
        }
    }
    else if (info->gx_animation_style | GX_ANIMATION_SCREEN_DRAG)
    {
        out = CString("GX_ANIMATION_SCREEN_DRAG");

        if (info->gx_animation_style & GX_ANIMATION_WRAP)
        {
            out += CString("|GX_ANIMATION_WRAP");
        }

        if (info->gx_animation_style & GX_ANIMATION_HORIZONTAL)
        {
            out += CString("|GX_ANIMATION_HORIZONTAL");
        }
        else if (info->gx_animation_style & GX_ANIMATION_VERTICAL)
        {
            out += CString("|GX_ANIMATION_VERTICAL");
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetStyleFlags(widget_info *info)
{
    CString out("    ");

    switch(info->style & GX_STYLE_BORDER_MASK)
    {
    case GX_STYLE_BORDER_RAISED:
        out += CString("GX_STYLE_BORDER_RAISED");
        break;

    case GX_STYLE_BORDER_RECESSED:
        out += CString("GX_STYLE_BORDER_RECESSED");
        break;
    
    case GX_STYLE_BORDER_THIN:
        out += CString("GX_STYLE_BORDER_THIN");
        break;

    case GX_STYLE_BORDER_THICK:
        out += CString("GX_STYLE_BORDER_THICK");
        break;

    case GX_STYLE_BORDER_NONE: 
    default:
        out += CString("GX_STYLE_BORDER_NONE");
        break;    
    }

    /* Define global style flags.  */
    if (info->style & GX_STYLE_TRANSPARENT)
    {
        out += CString("|GX_STYLE_TRANSPARENT");
    }
    if (info->style & GX_STYLE_DRAW_SELECTED)
    {
        out += CString("|GX_STYLE_DRAW_SELECTED");
    }
    if (info->style & GX_STYLE_ENABLED)
    {
        out += CString("|GX_STYLE_ENABLED");
    }
    if (info->style & GX_STYLE_TEXT_COPY)
    {
        out += CString("|GX_STYLE_TEXT_COPY");
    }

    if (m_project->mHeader.guix_version > 50000)
    {
        // templates cannot be dynamically allocated,
        // only widgets based on the template can be dynamically allocated
        if (!info->is_template)
        {
            if (info->allocation != STATICALLY_ALLOCATED)
            {
                out += CString("|GX_STYLE_DYNAMICALLY_ALLOCATED");
            }
        }
    }

    switch(info->basetype)
    {
    case GX_TYPE_ICON:
    case GX_TYPE_BUTTON:
    case GX_TYPE_RADIO_BUTTON:
    case GX_TYPE_CHECKBOX:
    case GX_TYPE_ICON_BUTTON:
    case GX_TYPE_TEXT_BUTTON:
    case GX_TYPE_PIXELMAP_BUTTON:
    case GX_TYPE_MULTI_LINE_TEXT_BUTTON:
        AddButtonStyles(info, out);

        if (info->basetype == GX_TYPE_ICON ||
            info->basetype == GX_TYPE_ICON_BUTTON ||
            info->basetype == GX_TYPE_PIXELMAP_BUTTON)
        {
            AddButtonAlignmentStyles(info, out);
        }
        break;

    case GX_TYPE_VERTICAL_LIST:
    case GX_TYPE_HORIZONTAL_LIST:
        AddListStyles(info, out);
        break;

    case GX_TYPE_VERTICAL_SCROLL:
    case GX_TYPE_HORIZONTAL_SCROLL:
        AddScrollbarStyles(info, out);
        break;

    case GX_TYPE_SLIDER:
    case GX_TYPE_PIXELMAP_SLIDER:
        /* Define Slider style flags.  */
        AddSliderStyles(info, out);

        if (info->basetype == GX_TYPE_PIXELMAP_SLIDER)
        {
            AddPixelmapSliderStyles(info, out);
        }
        break;

    case GX_TYPE_DROP_LIST:
        AddDropListStyles(info, out);
        break;

    case GX_TYPE_PROGRESS_BAR:
    case GX_TYPE_RADIAL_PROGRESS_BAR:
        AddProgressBarStyles(info, out);
        break;

    case GX_TYPE_SPRITE:
        AddSpriteStyles(info, out);
        break;

    case GX_TYPE_STRING_SCROLL_WHEEL:
    case GX_TYPE_NUMERIC_SCROLL_WHEEL:
        AddTextScrollWheelStyles(info, out);
        break;

    case GX_TYPE_GENERIC_SCROLL_WHEEL:
        AddWidgetScrollWheelStyles(info, out);
        break;

    case GX_TYPE_TREE_VIEW:
        AddTreeViewStyles(info, out);
        break;

    case GX_TYPE_SINGLE_LINE_TEXT_INPUT:
    case GX_TYPE_MULTI_LINE_TEXT_INPUT:
        AddTextInputStyles(info, out);
        break;
    }

    if (IsTextType(info))
    {
        AddTextAlignStyle(info, out);
    }

    if (info->basetype >= GX_TYPE_WINDOW)
    {
        AddWindowStyles(info, out);
    }

    out += CString(",   /* style flags */\n");
    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetStatusFlags(widget_info *info)
{
    CString out("    ");
    BOOL gen_reordered_bidi = FALSE;

    if ((info->basetype == GX_TYPE_MULTI_LINE_TEXT_VIEW) && (project_lib_version() >= GX_VERSION_GEN_LINE_BREAK_STATUS))
    {
        for (int lang = 0; lang < m_project->mHeader.num_languages; lang++)
        {
            if (m_project->mHeader.languages[lang].support_bidi_text &&
                m_project->mHeader.languages[lang].gen_reordered_bidi_text)
            {
                gen_reordered_bidi = TRUE;
                break;
            }
        }
    }

    if (info->accepts_focus || gen_reordered_bidi)
    {
        if (info->accepts_focus)
        {
            out += "GX_STATUS_ACCEPTS_FOCUS";
        }

        if (gen_reordered_bidi)
        {
            if (info->accepts_focus)
            {
                out += "|";
            }
            out += "GX_STATUS_LINE_BREAK_PROCESSED";
        }
    }
    else
    {
        out += "0";
    }

    out += ", /* status flags */\n";
    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetControlBlockSize(widget_info *info, BOOL bTop)
{
    CString out;
    CString upper_name;

    if (bTop)
    {
        upper_name = m_screen_name_prefix + info->app_name;
        upper_name.MakeUpper();
        out = CString("    sizeof(") + upper_name + CString("_CONTROL_BLOCK), /* control block size */\n");
    }
    else
    {
        widget_service_provider *provider = widget_factory::GetServiceProvider(info->basetype);

        if (provider)
        {
            if (info->basetype == GX_TYPE_TEMPLATE)
            {
                upper_name = m_screen_name_prefix + info->base_name;
                upper_name.MakeUpper();
                out = CString("    sizeof(") + upper_name + CString("_CONTROL_BLOCK), /* control block size */\n");
            }
            else
            {
                out = CString("    sizeof(") + provider->GetControlBlockName() + CString("), /* control block size */\n");
            }
        }
    }
    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetColors(widget_info *info)
{
    CString out;
    out.Format(_T("    %s,     /* normal color id */\n"), GetColorIdName(info->color_id[NORMAL_FILL_COLOR_INDEX]));
    FileWrite(out);
    out.Format(_T("    %s,     /* selected color id */\n"), GetColorIdName(info->color_id[SELECTED_FILL_COLOR_INDEX]));
    FileWrite(out);

    if (project_lib_version() > 50400)
    {
        out.Format(_T("    %s,     /* disabled color id */\n"), GetColorIdName(info->color_id[DISABLED_FILL_COLOR_INDEX]));
        FileWrite(out);
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetSize(widget_info *info)
{
    CString out;
    out.Format(_T("    {%d, %d, %d, %d},   /* widget size */\n"),
        info->size.gx_rectangle_left,
        info->size.gx_rectangle_top,
        info->size.gx_rectangle_right,
        info->size.gx_rectangle_bottom);
    FileWrite(out);
}


///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteCreateFunctionName(widget_info *info)
{
    CString out;
    widget_service_provider *provider = NULL;

    provider = widget_factory::GetServiceProvider(info->basetype);
        
    if (provider)
    {
        out.Format(_T("    %s,     /* create function */\n"), provider->GetCreateFromDefFunctionName());
        FileWrite(out);
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetOverrides(widget_info *info)
{
    CString out;

    if (info->draw_func.IsEmpty())
    {   
	    FileWrite(CString("    GX_NULL, /* drawing function override */\n"));		// no drawing override
    }
    else
    {
        out.Format(_T("    (VOID (*)(GX_WIDGET *)) %s, /* drawing function override */\n"), info->draw_func);
        FileWrite(out);
    }

    /* write out the event process function */
    
    BOOL bHasScreenFlow = FALSE;

    /* We only create screen flow records for top-level widgets today */
    if (GetProjectView() && GetProjectView()->IsTopLevelWidget(info))
    {
        screen_flow *flow = m_project->mDisplays[m_display].screenflow;

        if (flow)
        {
            flow_item *item = flow->GetFlowItem(info->app_name);
            if (item)
            {
                if (item->trigger_list)
                {
                    bHasScreenFlow = TRUE;
                    out.Format(_T("    (UINT (*)(GX_WIDGET *, GX_EVENT *)) gx_studio_%s_event_process, /* event function override */\n"), m_screen_name_prefix + info->app_name);
                    FileWrite(out);
                }
            }
        }
    }

    if (!bHasScreenFlow)
    {
        if (info->event_func.IsEmpty())
        {   
	        FileWrite(CString("    GX_NULL, /* event function override */\n"));		// no event override
        }
        else
        {
            out.Format(_T("    (UINT (*)(GX_WIDGET *, GX_EVENT *)) %s, /* event function override */\n"), info->event_func);
            FileWrite(out);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteChildDefine(CString &parent_name, widget_info *info)
{
    CString out;
    CString upper_name;
    widget_info *stop = NULL;

    if (!info)
    {
        return;
    }
    if (info->GetChildWidgetInfo())
    {
        WriteChildDefine(parent_name, info->GetChildWidgetInfo());
    }

    if (info->GetNextWidgetInfo())
    {
        // only do one level of next, because next will do it's own next    
        WriteChildDefine(parent_name, info->GetNextWidgetInfo());
    }

    if (m_project->mHeader.guix_version < 50100)
    {
        out.Format(_T("\nGX_STUDIO_WIDGET %s_%s_define =\n{\n"), parent_name, info->app_name);
    }
    else
    {
        out.Format(_T("\nGX_CONST GX_STUDIO_WIDGET %s_%s_define =\n{\n"), parent_name, info->app_name);
    }
    FileWrite(out);

    // Write the app name
    out.Format(_T("    \"%s\",\n"), info->app_name);
    FileWrite(out);

    // write the widget type id
    WriteWidgetType(info);
    WriteWidgetId(info);
    if (m_project->mHeader.guix_version > 50205)
    {
        WriteWidgetUserData(info);
    }
    WriteWidgetStyleFlags(info);
    WriteWidgetStatusFlags(info);
    WriteWidgetControlBlockSize(info);
    WriteWidgetColors(info);
    WriteCreateFunctionName(info);
    WriteWidgetOverrides(info);
    WriteWidgetSize(info);

    if (info->GetNextWidgetInfo())
    {
        out.Format(_T("    &%s_%s_define, /* next widget definition */\n"), parent_name, info->GetNextWidgetInfo()->app_name);
        FileWrite(out);
    }
    else
    {
        FileWrite(CString("    GX_NULL, /* no next widget */\n"));
    }

    if (info->GetChildWidgetInfo())
    {
        out.Format(_T("    &%s_%s_define, /* child widget definition */\n"), parent_name, info->GetChildWidgetInfo()->app_name);
        FileWrite(out);
    }
    else
    {
        FileWrite(CString("    GX_NULL, /* no child widgets */ \n"));
    }
    if (m_project->mHeader.guix_version < 50100 ||
        info->allocation == STATICALLY_ALLOCATED)
    {
        upper_name = parent_name;
        upper_name.MakeUpper();
        out.Format(_T("    offsetof(%s_CONTROL_BLOCK, %s_%s), /* control block */\n"), upper_name, parent_name, info->app_name);
    }
    else
    {
        out.Format(_T("    0, /* runtime control block */\n"));
    }
    FileWrite(out);

    // check to see if this widget has any extended properties
    out = _T("    (void *) GX_NULL /* no extended properties */\n};\n");

    widget_service_provider *provider = widget_factory::GetServiceProvider(info->basetype);
    if (provider)
    {
        CString write_string = provider->WriteExtendedProperties(this, CString("---"), info);
        if (!write_string.IsEmpty())
        {
            out.Format(_T("    (void *) &%s_%s_properties /* extended properties */\n};\n"), parent_name, info->app_name);
        }
    }
    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteParentDefine(widget_info *info)
{
    CString out;

    if (m_project->mHeader.guix_version < 50100)
    {
        out.Format(_T("\nGX_STUDIO_WIDGET %s_define =\n{\n"), info->app_name);
    }
    else
    {
        out.Format(_T("\nGX_CONST GX_STUDIO_WIDGET %s%s_define =\n{\n"), m_screen_name_prefix, info->app_name);
    }
    FileWrite(out);

    // Write the app name
    out.Format(_T("    \"%s\",\n"), m_screen_name_prefix + info->app_name);
    FileWrite(out);

    // write the widget type id
    WriteWidgetType(info);
    WriteWidgetId(info);
    if (m_project->mHeader.guix_version > 50205)
    {
        WriteWidgetUserData(info);
    }
    WriteWidgetStyleFlags(info);
    WriteWidgetStatusFlags(info);
    WriteWidgetControlBlockSize(info, TRUE);
    WriteWidgetColors(info);
    WriteCreateFunctionName(info);
    WriteWidgetOverrides(info);
    WriteWidgetSize(info);

    FileWrite(CString("    GX_NULL, /* next widget */\n"));      // next

    if (info->GetChildWidgetInfo())
    {
        out.Format(_T("    &%s%s_%s_define, /* child widget */\n"), m_screen_name_prefix, info->app_name, info->GetChildWidgetInfo()->app_name);
        FileWrite(out);
    }
    else
    {
        FileWrite(CString("    GX_NULL, /* child widget */\n"));
    }


    out.Format(_T("    0, /* control block */\n"));      // control block
    FileWrite(out);

    // check to see if this widget has any extended properties
    out = "    (void *) GX_NULL /* extended properties */\n};\n";

    widget_service_provider *provider = widget_factory::GetServiceProvider(info->basetype);
    if (provider)
    {
        CString write_string = provider->WriteExtendedProperties(this, CString("---"), info);
        if (!write_string.IsEmpty())
        {
            out.Format(_T("    (void *) &%s%s_properties /* extended properties */\n};\n"), m_screen_name_prefix, info->app_name);
        }
    }
    FileWrite(out);

}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetIds(folder_info *folder)
{
    while (folder)
    {
        WriteWidgetIds(folder->GetFirstChildWidget());
        folder = folder->GetNextFolder();
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetIds(widget_info *info)
{
    CString out;

    while(info)
    {
        if (!info->id_name.IsEmpty())
        {
            if (!IsItemInArray<CString>(name_list, info->id_name))
            {
                out.Format(_T("#define %s %d\n"), info->id_name, m_widget_id);
                FileWrite(out);
                m_widget_id++;
                name_list.Add(info->id_name);
            }
        }
        if (info->GetChildWidgetInfo())
        {
            WriteWidgetIds(info->GetChildWidgetInfo());
        }
        info = info->GetNextWidgetInfo();
    }
}

///////////////////////////////////////////////////////////////////////////////
BOOL screen_generator::TypedefControlBlock(folder_info *folder)
{
    CString out;
    folder_info *start_folder;
    widget_info *start_widget;
    CString upper_name;
    BOOL completed = TRUE;

    start_folder = folder;
    while (start_folder)
    {
        start_widget = start_folder->GetFirstChildWidget();
        while (start_widget)
        {
            if (IsItemInArray<CString>(name_list, m_screen_name_prefix + start_widget->app_name))
            {
                start_widget = start_widget->GetNextWidgetInfo();
                continue;
            }

            if (!CheckDependencies(start_widget, TRUE))
            {
                completed = FALSE;
                start_widget = start_widget->GetNextWidgetInfo();
                continue;
            }

            name_list.Add(m_screen_name_prefix + start_widget->app_name);
            upper_name = m_screen_name_prefix + start_widget->app_name;
            upper_name.MakeUpper();

            out.Format(_T("typedef struct %s_CONTROL_BLOCK_STRUCT\n{\n"), upper_name);
            FileWrite(out);

            DeclareBaseMembers(start_widget);

            if (m_project->mHeader.guix_version < 50100 ||
                start_widget->allocation == STATICALLY_ALLOCATED)
            {
                DeclareChildMembers(m_screen_name_prefix + start_widget->app_name, start_widget->GetChildWidgetInfo());
            }

            out.Format(_T("} %s_CONTROL_BLOCK;\n\n"), upper_name);
            FileWrite(out);
            start_widget = start_widget->GetNextWidgetInfo();
        }

        start_folder = start_folder->GetNextFolder();
    }

    if (completed)
    {
        WriteComment("extern statically defined control blocks");
        out.Format(_T("#ifndef GUIX_STUDIO_GENERATED_FILE\n"));
        FileWrite(out);
        start_folder = folder;
        while (start_folder)
        {
            start_widget = start_folder->GetFirstChildWidget();
            while (start_widget)
            {
                upper_name = m_screen_name_prefix + start_widget->app_name;
                upper_name.MakeUpper();
                if (m_project->mHeader.guix_version < 50100 ||
                    start_widget->allocation == STATICALLY_ALLOCATED)
                {
                    out.Format(_T("extern %s_CONTROL_BLOCK %s%s;\n"), upper_name, m_screen_name_prefix, start_widget->app_name);
                    FileWrite(out);
                }
                start_widget = start_widget->GetNextWidgetInfo();
            }
            start_folder = start_folder->GetNextFolder();
        }
        out.Format(_T("#endif\n"));
        FileWrite(out);
    }

    return completed;
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::PrototypeCallbacks(widget_info *info)
{
    CString out;
    while(info)
    {
        if (!info->callback_func.IsEmpty())
        {
            switch(info->basetype)
            {
            case GX_TYPE_VERTICAL_LIST:
            case GX_TYPE_DROP_LIST:
                out.Format(_T("VOID %s(GX_VERTICAL_LIST *, GX_WIDGET *, INT);\n"), info->callback_func);

                if (!IsItemInArray<CString>(name_list, out))
                {
                    FileWrite(out);
                    name_list.Add(out);
                }
                break;
            
            case GX_TYPE_HORIZONTAL_LIST:
                out.Format(_T("VOID %s(GX_HORIZONTAL_LIST *, GX_WIDGET *, INT);\n"), info->callback_func);

                if (!IsItemInArray<CString>(name_list, out))
                {
                    FileWrite(out);
                    name_list.Add(out);
                }
                break;
            case GX_TYPE_STRING_SCROLL_WHEEL:
                out.Format(_T("GX_CONST GX_CHAR *%s(GX_STRING_SCROLL_WHEEL *wheel, INT row);\n"), info->callback_func);
                if (!IsItemInArray<CString>(name_list, out))
                {
                    FileWrite(out);
                    name_list.Add(out);
                }
                break;

            case GX_TYPE_NUMERIC_SCROLL_WHEEL:
                if (project_lib_version() >= GX_VERSION_STRING_LENGTH_FIX)
                {
                    out.Format(_T("UINT %s(GX_NUMERIC_SCROLL_WHEEL *wheel, INT row, GX_STRING *string);\n"), info->callback_func);
                }
                else
                {
                    out.Format(_T("GX_CONST GX_CHAR *%s(GX_NUMERIC_SCROLL_WHEEL *wheel, INT row);\n"), info->callback_func);
                }

                if (!IsItemInArray<CString>(name_list, out))
                {
                    FileWrite(out);
                    name_list.Add(out);
                }
                break;

            case GX_TYPE_GENERIC_SCROLL_WHEEL:
                out.Format(_T("VOID %s(GX_GENERIC_SCROLL_WHEEL *wheel, GX_WIDGET *widget, INT);\n"), info->callback_func);

                if (!IsItemInArray<CString>(name_list, out))
                {
                    FileWrite(out);
                    name_list.Add(out);
                }
                break;

            case GX_TYPE_RADIAL_SLIDER:
                out.Format(_T("VOID %s(GX_RADIAL_SLIDER *slider);\n"), info->callback_func);
                if (!IsItemInArray<CString>(name_list, out))
                {
                    FileWrite(out);
                    name_list.Add(out);
                }
                break;

            default:
                break;
                
            }
        }

        if (!info->format_func.IsEmpty())
        {
            switch ( info->basetype)
            {
            case GX_TYPE_NUMERIC_PROMPT:
                out.Format(_T("VOID %s(GX_NUMERIC_PROMPT *, INT);\n"), info->format_func);

                if (!IsItemInArray<CString>(name_list, out))
                {
                    FileWrite(out);
                    name_list.Add(out);
                }
                break;

            case GX_TYPE_NUMERIC_PIXELMAP_PROMPT:
                out.Format(_T("VOID %s(GX_NUMERIC_PIXELMAP_PROMPT *, INT);\n"), info->format_func);

                if (!IsItemInArray<CString>(name_list, out))
                {
                    FileWrite(out);
                    name_list.Add(out);
                }
                break;
            default:
                break;
            }
        }

        CString widget_type("GX_WIDGET");

        widget_service_provider *provider;

        if (info->basetype == GX_TYPE_TEMPLATE)
        {
            widget_info *base = template_service_provider::GetBaseInfo(info);

            while (base->basetype == GX_TYPE_TEMPLATE)
            {
                base = template_service_provider::GetBaseInfo(base);
            }

            if (base)
            {
                provider = widget_factory::GetServiceProvider(base->basetype);
            }
        }
        else
        {
            provider = widget_factory::GetServiceProvider(info->basetype);
        }

        if (provider)
        {
            widget_type = provider->GetControlBlockName();
        }

        if (!info->event_func.IsEmpty())
        {
            out.Format(_T("UINT %s(%s *widget, GX_EVENT *event_ptr);\n"),
                info->event_func, widget_type);
            if (!IsItemInArray<CString>(name_list, out))
            {
                FileWrite(out);
                name_list.Add(out);
            }
        }
        if (!info->draw_func.IsEmpty())
        {
            out.Format(_T("VOID %s(%s *widget);\n"),
                info->draw_func, widget_type);
            if (!IsItemInArray<CString>(name_list, out))
            {
                FileWrite(out);
                name_list.Add(out);
            }
        }
        if (info->GetChildWidgetInfo())
        {
            PrototypeCallbacks(info->GetChildWidgetInfo());
        }
        info = info->GetNextWidgetInfo();
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteExternWidgetsUsedByScreenFlow(folder_info *folder, int display_index)
{
    widget_info *info = NULL;
    widget_info *target = NULL;
    folder_info *first_folder;
    flow_item   *item;
    screen_flow *flow;
    trigger_info *trigger;
    action_info *action;
    folder_info *parent_folder;
    CString      target_name;

    flow = m_project->mDisplays[display_index].screenflow;
    first_folder = m_project->mDisplays[display_index].GetFirstChildFolder();

    /* Create extern screen list. */
    if (flow && SetOutFile(folder->output_filename))
    {
        info = folder->GetFirstChildWidget();
        while (info)
        {
            /* Get action target. */
            item = flow->GetFlowItem(info->app_name);
            if (item)
            {
                trigger = item->trigger_list;
                while (trigger)
                {
                    int action_count = trigger->action_list.GetCount();

                    for (int action_index = 0; action_index < action_count; action_index++)
                    {
                        action = trigger->action_list[action_index];

                        /* Get action parent. */
                        target_name.Format(_T("%d_"), display_index);
                        target_name += action->parent_widget_name;
                        if (!IsItemInArray<CString>(name_list, target_name))
                        {
                            name_list.Add(target_name);
                            if (action->parent_show_child_widgets)
                            {
                                target = m_project->FindWidgetInfo(first_folder, item->screen_name, FALSE);
                                target = m_project->FindWidgetInfo(target->GetChildWidgetInfo(), action->parent_widget_name, TRUE);
                            }
                            else
                            {
                                target = m_project->FindWidgetInfo(first_folder, action->parent_widget_name, FALSE);
                            }

                            if (target)
                            {
                                parent_folder = m_project->FindParentFolderInfo(target);
                                if (parent_folder->output_filename != folder->output_filename)
                                {
                                    /* If target not in current file. extern it. */
                                    WriteExternWidget(target);
                                }
                            }
                        }

                        /* Get action target. */
                        target_name.Format(_T("%d_"), display_index);
                        target_name += action->target_widget_name;
                        if (!IsItemInArray<CString>(name_list, target_name))
                        {
                            name_list.Add(target_name);

                            if (action->target_show_child_widgets)
                            {
                                target = m_project->FindWidgetInfo(first_folder, item->screen_name, FALSE);
                                target = m_project->FindWidgetInfo(target->GetChildWidgetInfo(), action->target_widget_name, TRUE);
                            }
                            else
                            {
                                target = m_project->FindWidgetInfo(first_folder, action->target_widget_name, FALSE);
                            }

                            if (target)
                            {
                                parent_folder = m_project->FindParentFolderInfo(target);
                                if (parent_folder->output_filename != folder->output_filename)
                                {
                                    /* If target not in current file. extern it. */
                                    WriteExternWidget(target);
                                }
                            }
                        }
                    }
                    trigger = trigger->next;
                }
            }
            info = info->GetNextWidgetInfo();
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteExternWidget(widget_info *&info)
{
    CString out;
    /* Upper for extern control block. */
    CString upper_name = m_screen_name_prefix + info->app_name;
    upper_name.MakeUpper();

    /* extern window define. */
    if (m_project->mHeader.guix_version < 50100)
    {
        out.Format(_T("extern GX_CONST GX_STUDIO_WIDGET %s_define;\n"), info->app_name);
        FileWrite(out);
        out.Format(_T("extern %s_CONTROL_BLOCK %s;\n"), upper_name, info->app_name);
        FileWrite(out);
    }
    else
    {
        out.Format(_T("extern GX_CONST GX_STUDIO_WIDGET %s%s_define;\n"), m_screen_name_prefix, info->app_name);
        FileWrite(out);
        if (info->allocation == STATICALLY_ALLOCATED && (!info->is_template))
        {
            out.Format(_T("extern %s_CONTROL_BLOCK %s%s;\n"), upper_name, m_screen_name_prefix, info->app_name);
            FileWrite(out);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////
// This function externs the widgets that are written to custom output files
// to the default output file, so that we can build the widget table in the default output
// file.
//
void screen_generator::WriteExternWidgetsToDefaultFile()
{
    int display;
    folder_info *folder;
    widget_info *info;
    CFile *testfile;

    /* First, write extern list for default file, which is used by widget table. */
    if (SetOutFile(CString("")))
    {
        m_screen_name_prefix = _T("");

        for (display = 0; display < m_project->mHeader.num_displays; display++)
        {
            if (m_project->mHeader.num_displays > 1)
            {
                m_screen_name_prefix = m_project->mDisplays[display].name + _T("_");
            }

            folder = m_project->mDisplays[display].GetFirstChildFolder();
            testfile = output_file_list.GetAt(0);

            if (!testfile)
            {
                return;
            }

            CString default_filename = testfile->GetFileName();
            CString folder_filename;

            while (folder)
            {
                if (!folder->output_filename.IsEmpty())
                {
                    folder_filename = folder->output_filename + _T(".c");
                    if (folder_filename != default_filename)
                    {
                        info = folder->GetFirstChildWidget();
                        while (info)
                        {
                            WriteExternWidget(info);
                            info = info->GetNextWidgetInfo();
                        }
                    }
                }
                folder = folder->GetNextFolder();
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteExternWidgetsUsedByScreenFlow()
{
    // extern widgets that needed by screen flows

    folder_info *folder;
    CArray<folder_info *> written_folder_list;
    BOOL completed = FALSE;
    CString current_output_filename;
    CFile *default_file = output_file_list.GetAt(0);

    if (!default_file)
    {
        return;
    }

    // get default specification file name
    CString default_filename = default_file->GetFileName();
    CString custom_filename;

    while (!completed)
    {
        completed = TRUE;
        name_list.RemoveAll();
        current_output_filename.Empty();
        m_screen_name_prefix = _T("");

        for (int display = 0; display < m_project->mHeader.num_displays; display++)
        {
            if (m_project->mHeader.num_displays > 1)
            {
                m_screen_name_prefix = m_project->mDisplays[display].name + _T("_");
            }

            folder = m_project->mDisplays[display].GetFirstChildFolder();

            while (folder)
            {
                if (folder->output_filename.IsEmpty())
                {
                    custom_filename = default_filename;
                }
                else
                {
                    custom_filename = folder->output_filename + _T(".c");
                }

                if ((custom_filename != default_filename) &&
                    !IsItemInArray<folder_info *>(written_folder_list, folder))
                {
                    // test folder that has custom output specification name.

                    if (current_output_filename.IsEmpty())
                    {
                        // set current output filename
                        current_output_filename = folder->output_filename;
                    }

                    if (folder->output_filename == current_output_filename)
                    {
                        // extern widgets that used by screen flows
                        // owned by widgets under all folders that has the same output filename.
                        WriteExternWidgetsUsedByScreenFlow(folder, display);
                        written_folder_list.Add(folder);
                    }
                    else
                    {
                        // still need to check from first folder
                        completed = FALSE;
                    }
                }

                folder = folder->GetNextFolder();
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::DeclareControlBlocks()
{
    m_screen_name_prefix = _T("");

    for (int display = 0; display < m_project->mHeader.num_displays; display++)
    {
        if (m_project->mHeader.num_displays > 1)
        {
            m_screen_name_prefix = m_project->mDisplays[display].name + _T("_");
        }
        folder_info *folder = m_project->mDisplays[display].GetFirstChildFolder();

        while (folder)
        {
            /* Check file. */
            if (SetOutFile(folder->output_filename))
            {
                DeclareControlBlocks(folder->GetFirstChildWidget());
            }
            folder = folder->GetNextFolder();
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::DeclareControlBlocks(widget_info *info)
{
    CString out;
    widget_info *current = info;

    while(current)
    {
        CString upper_name = m_screen_name_prefix + current->app_name;
        upper_name.MakeUpper();

        if (m_project->mHeader.guix_version < 50100) 
        {
            out.Format(_T("%s_CONTROL_BLOCK %s;\n"), upper_name, current->app_name);
            FileWrite(out);
        }
        else
        {
            if (current->allocation == STATICALLY_ALLOCATED &&
                !current->is_template)
            {
                out.Format(_T("%s_CONTROL_BLOCK %s%s;\n"), upper_name, m_screen_name_prefix, current->app_name);
                FileWrite(out);
            }
        }
        current = current->GetNextWidgetInfo();
    }

    /* forward reference for dynamically allocated control blocks */
    current = info;

    while(current)
    {
        if (current->allocation != STATICALLY_ALLOCATED &&
                !current->is_template)
        {
            out.Format(_T("GX_CONST GX_STUDIO_WIDGET %s%s_define;\n"), m_screen_name_prefix, current->app_name);
            FileWrite(out);
        }
        current = current->GetNextWidgetInfo();
    }
}

char *widget_loaders_542 = "\n"



"static GX_WIDGET *gx_studio_nested_widget_create(GX_BYTE *control, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent)\n"
"{\n"
"    UINT status = GX_SUCCESS;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"    GX_VALUE   list_count = 0;\n"
"    GX_VALUE   list_total_count = 0;\n"
"\n"
"    if(parent && (parent->gx_widget_type == GX_TYPE_MENU))\n"
"    {\n"
"        list_total_count = ((GX_MENU *)parent)->gx_menu_list_total_count;\n"
"    }\n"
"\n"
"    while(definition && status == GX_SUCCESS)\n"
"    {\n"
"        if (definition->create_function)\n"
"        {\n"
"            if (definition->style & GX_STYLE_DYNAMICALLY_ALLOCATED)\n"
"            {\n"
"                status = gx_widget_allocate(&widget, definition->control_block_size);\n"
"                if (status != GX_SUCCESS)\n"
"                {\n"
"                    return GX_NULL;\n"
"                }\n"
"            }\n"
"            else\n"
"            {\n"
"                if (control == GX_NULL)\n"
"                {\n"
"                    return GX_NULL;\n"
"                }\n"
"                widget = (GX_WIDGET *) (control + definition->control_block_offset);\n"
"            }\n"
"\n"
"            status = definition->create_function(definition, widget, parent);\n"
"\n"
"            if(list_count < list_total_count)\n"
"            {\n"
"                gx_menu_insert((GX_MENU *)parent, widget);\n"
"                ((GX_MENU *)parent)->gx_menu_list_total_count--;\n"
"                list_count++;\n"
"            }\n"
"\n"
"            if (status == GX_SUCCESS)\n"
"            {\n"
"                if (definition->widget_type != GX_TYPE_TEMPLATE)\n"
"                {\n"
"#if defined(GUIX_5_4_0_COMPATIBILITY)\n"
"                    gx_widget_fill_color_set(widget, definition->normal_fill_color_id, definition->selected_fill_color_id);\n"
"#else\n"
"                    gx_widget_fill_color_set(widget, definition->normal_fill_color_id, definition->selected_fill_color_id, definition->disabled_fill_color_id);\n"
"#endif\n"
"                }\n"
"\n"
"                if (!(definition->status & GX_STATUS_ACCEPTS_FOCUS))\n"
"                {\n"
"                    gx_widget_status_remove(widget, GX_STATUS_ACCEPTS_FOCUS);\n"
"                }\n"
"\n"
"                if (definition->draw_function)\n"
"                {\n"
"                    gx_widget_draw_set(widget, definition->draw_function);\n"
"                }\n"
"                if (definition->event_function)\n"
"                {\n"
"                    gx_widget_event_process_set(widget, definition->event_function);\n"
"                }\n"
"\n"
"                #if defined(GX_WIDGET_USER_DATA)\n"
"                widget->gx_widget_user_data = definition->user_data;\n"
"                #endif\n"
"\n"
"                if (definition->child_widget)\n"
"                {\n"
"                    gx_studio_nested_widget_create(control, definition->child_widget, widget);\n"
"                }\n"
"            }\n"
"            definition = definition->next_widget;\n"
"        }\n"
"    }\n"
"    return widget;\n"
"}\n"
"\n"
"GX_WIDGET *gx_studio_widget_create(GX_BYTE *control, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent)\n"
"{\n"
"    GX_WIDGET *widget;\n"
"    widget = gx_studio_nested_widget_create(control, definition, GX_NULL);\n"
"\n"
"    if (parent && widget)\n"
"    {\n"
"        gx_widget_attach(parent, widget);\n"
"    }\n"
"    return widget;\n"
"}\n"
"\n"
"UINT gx_studio_named_widget_create(char *name, GX_WIDGET *parent, GX_WIDGET **new_widget)\n"
"{\n"
"    UINT status = GX_FAILURE;\n"
"    GX_CONST GX_STUDIO_WIDGET_ENTRY *entry = %s_widget_table;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"\n"
"    while(entry->widget_information)\n"
"    {\n"
"        if (!strcmp(name, entry->widget_information->widget_name))\n"
"        {\n"
"            widget = gx_studio_widget_create((GX_BYTE *) entry->widget, entry->widget_information, parent);\n"
"            if (widget)\n"
"            {\n"
"                status = GX_SUCCESS;\n"
"            }\n"
"            break;\n"
"        }\n"
"        entry++;\n"
"    }\n"
"\n"
"    if (new_widget)\n"
"    {\n"
"        *new_widget = widget;\n"
"    }\n"
"    return status;\n"
"}\n\n";

char *widget_loaders_54 = "\n"



"static GX_WIDGET *gx_studio_nested_widget_create(GX_BYTE *control, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent)\n"
"{\n"
"    UINT status = GX_SUCCESS;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"    GX_VALUE   list_count = 0;\n"
"    GX_VALUE   list_total_count = 0;\n"
"\n"
"    if(parent && (parent->gx_widget_type == GX_TYPE_MENU))\n"
"    {\n"
"        list_total_count = ((GX_MENU *)parent)->gx_menu_list_total_count;\n"
"    }\n"
"\n"
"    while(definition && status == GX_SUCCESS)\n"
"    {\n"
"        if (definition->create_function)\n"
"        {\n"
"            if (definition->style & GX_STYLE_DYNAMICALLY_ALLOCATED)\n"
"            {\n"
"                status = gx_widget_allocate(&widget, definition->control_block_size);\n"
"                if (status != GX_SUCCESS)\n"
"                {\n"
"                    return GX_NULL;\n"
"                }\n"
"            }\n"
"            else\n"
"            {\n"
"                if (control == GX_NULL)\n"
"                {\n"
"                    return GX_NULL;\n"
"                }\n"
"                widget = (GX_WIDGET *) (control + definition->control_block_offset);\n"
"            }\n"
"\n"
"            status = definition->create_function(definition, widget, parent);\n"
"\n"
"            if(list_count < list_total_count)\n"
"            {\n"
"                gx_menu_insert((GX_MENU *)parent, widget);\n"
"                ((GX_MENU *)parent)->gx_menu_list_total_count--;\n"
"                list_count++;\n"
"            }\n"
"\n"
"            if (status == GX_SUCCESS)\n"
"            {\n"
"                if (definition->widget_type != GX_TYPE_TEMPLATE)\n"
"                {\n"
"                    gx_widget_fill_color_set(widget, definition->normal_fill_color_id, definition->selected_fill_color_id);\n"
"                }\n"
"\n"
"                if (!(definition->status & GX_STATUS_ACCEPTS_FOCUS))\n"
"                {\n"
"                    gx_widget_status_remove(widget, GX_STATUS_ACCEPTS_FOCUS);\n"
"                }\n"
"\n"
"                if (definition->draw_function)\n"
"                {\n"
"                    gx_widget_draw_set(widget, definition->draw_function);\n"
"                }\n"
"                if (definition->event_function)\n"
"                {\n"
"                    gx_widget_event_process_set(widget, definition->event_function);\n"
"                }\n"
"\n"
"                #if defined(GX_WIDGET_USER_DATA)\n"
"                widget->gx_widget_user_data = definition->user_data;\n"
"                #endif\n"
"\n"
"                if (definition->child_widget)\n"
"                {\n"
"                    gx_studio_nested_widget_create(control, definition->child_widget, widget);\n"
"                }\n"
"            }\n"
"            definition = definition->next_widget;\n"
"        }\n"
"    }\n"
"    return widget;\n"
"}\n"
"\n"
"GX_WIDGET *gx_studio_widget_create(GX_BYTE *control, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent)\n"
"{\n"
"    GX_WIDGET *widget;\n"
"    widget = gx_studio_nested_widget_create(control, definition, GX_NULL);\n"
"\n"
"    if (parent && widget)\n"
"    {\n"
"        gx_widget_attach(parent, widget);\n"
"    }\n"
"    return widget;\n"
"}\n"
"\n"
"UINT gx_studio_named_widget_create(char *name, GX_WIDGET *parent, GX_WIDGET **new_widget)\n"
"{\n"
"    UINT status = GX_FAILURE;\n"
"    GX_CONST GX_STUDIO_WIDGET_ENTRY *entry = %s_widget_table;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"\n"
"    while(entry->widget_information)\n"
"    {\n"
"        if (!strcmp(name, entry->widget_information->widget_name))\n"
"        {\n"
"            widget = gx_studio_widget_create((GX_BYTE *) entry->widget, entry->widget_information, parent);\n"
"            if (widget)\n"
"            {\n"
"                status = GX_SUCCESS;\n"
"            }\n"
"            break;\n"
"        }\n"
"        entry++;\n"
"    }\n"
"\n"
"    if (new_widget)\n"
"    {\n"
"        *new_widget = widget;\n"
"    }\n"
"    return status;\n"
"}\n\n";

char *widget_loaders_53 = "\n"



"static GX_WIDGET *gx_studio_nested_widget_create(GX_BYTE *control, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent)\n"
"{\n"
"    UINT status = GX_SUCCESS;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"\n"
"    while(definition && status == GX_SUCCESS)\n"
"    {\n"
"        if (definition->create_function)\n"
"        {\n"
"            if (definition->style & GX_STYLE_DYNAMICALLY_ALLOCATED)\n"
"            {\n"
"                status = gx_widget_allocate(&widget, definition->control_block_size);\n"
"                if (status != GX_SUCCESS)\n"
"                {\n"
"                    return GX_NULL;\n"
"                }\n"
"            }\n"
"            else\n"
"            {\n"
"                if (control == GX_NULL)\n"
"                {\n"
"                    return GX_NULL;\n"
"                }\n"
"                widget = (GX_WIDGET *) (control + definition->control_block_offset);\n"
"            }\n"
"\n"
"            status = definition->create_function(definition, widget, parent);\n"
"\n"
"            if (status == GX_SUCCESS)\n"
"            {\n"
"                if (definition->widget_type != GX_TYPE_TEMPLATE)\n"
"                {\n"
"                    gx_widget_fill_color_set(widget, definition->normal_fill_color_id, definition->selected_fill_color_id);\n"
"                }\n"
"\n"
"                if (!(definition->status & GX_STATUS_ACCEPTS_FOCUS))\n"
"                {\n"
"                    gx_widget_status_remove(widget, GX_STATUS_ACCEPTS_FOCUS);\n"
"                }\n"
"\n"
"                if (definition->draw_function)\n"
"                {\n"
"                    gx_widget_draw_set(widget, definition->draw_function);\n"
"                }\n"
"                if (definition->event_function)\n"
"                {\n"
"                    gx_widget_event_process_set(widget, definition->event_function);\n"
"                }\n"
"\n"
"                #if defined(GX_WIDGET_USER_DATA)\n"
"                widget->gx_widget_user_data = definition->user_data;\n"
"                #endif\n"
"\n"
"                if (definition->child_widget)\n"
"                {\n"
"                    gx_studio_nested_widget_create(control, definition->child_widget, widget);\n"
"                }\n"
"            }\n"
"            definition = definition->next_widget;\n"
"        }\n"
"    }\n"
"    return widget;\n"
"}\n"
"\n"
"GX_WIDGET *gx_studio_widget_create(GX_BYTE *control, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent)\n"
"{\n"
"    GX_WIDGET *widget;\n"
"    widget = gx_studio_nested_widget_create(control, definition, GX_NULL);\n"
"\n"
"    if (parent && widget)\n"
"    {\n"
"        gx_widget_attach(parent, widget);\n"
"    }\n"
"    return widget;\n"
"}\n"
"\n"
"UINT gx_studio_named_widget_create(char *name, GX_WIDGET *parent, GX_WIDGET **new_widget)\n"
"{\n"
"    UINT status = GX_FAILURE;\n"
"    GX_CONST GX_STUDIO_WIDGET_ENTRY *entry = %s_widget_table;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"\n"
"    while(entry->widget_information)\n"
"    {\n"
"        if (!strcmp(name, entry->widget_information->widget_name))\n"
"        {\n"
"            widget = gx_studio_widget_create((GX_BYTE *) entry->widget, entry->widget_information, parent);\n"
"            if (widget)\n"
"            {\n"
"                status = GX_SUCCESS;\n"
"            }\n"
"            break;\n"
"        }\n"
"        entry++;\n"
"    }\n"
"\n"
"    if (new_widget)\n"
"    {\n"
"        *new_widget = widget;\n"
"    }\n"
"    return status;\n"
"}\n\n";

char *widget_loaders_52 = "\n"
"GX_WIDGET *gx_studio_widget_create(GX_BYTE *control, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent)\n"
"{\n"
"    UINT status = GX_SUCCESS;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"\n"
"    while(definition && status == GX_SUCCESS)\n"
"    {\n"
"        if (definition->create_function)\n"
"        {\n"
"            if (definition->style & GX_STYLE_DYNAMICALLY_ALLOCATED)\n"
"            {\n"
"                status = gx_widget_allocate(&widget, definition->control_block_size);\n"
"                if (status != GX_SUCCESS)\n"
"                {\n"
"                    return GX_NULL;\n"
"                }\n"
"            }\n"
"            else\n"
"            {\n"
"                if(!control)\n"
"                {\n"
"                    return GX_NULL;\n"
"                }\n"
"\n"
"                widget = (GX_WIDGET *) (control + definition->control_block_offset);\n"
"            }\n"
"\n"
"            status = definition->create_function(definition, widget, parent);\n"
"\n"
"            if (status == GX_SUCCESS)\n"
"            {\n"
"                gx_widget_fill_color_set(widget, definition->normal_fill_color_id, definition->selected_fill_color_id);\n"
"\n"
"                if (!(definition->status & GX_STATUS_ACCEPTS_FOCUS))\n"
"                {\n"
"                    gx_widget_status_remove(widget, GX_STATUS_ACCEPTS_FOCUS);\n"
"                }\n"
"\n"
"                if (definition->draw_function)\n"
"                {\n"
"                    gx_widget_draw_set(widget, definition->draw_function);\n"
"                }\n"
"                if (definition->event_function)\n"
"                {\n"
"                    gx_widget_event_process_set(widget, definition->event_function);\n"
"                }\n"
"\n"
"                #if defined(GX_WIDGET_USER_DATA)\n"
"                widget->gx_widget_user_data = definition->user_data;\n"
"                #endif\n"
"\n"
"                if (definition->child_widget)\n"
"                {\n"
"                    gx_studio_widget_create(control, definition->child_widget, widget);\n"
"                }\n"
"            }\n"
"            definition = definition->next_widget;\n"
"        }\n"
"    }\n"
"    return widget;\n"
"}\n"
"\n"
"\n"
"UINT gx_studio_named_widget_create(char *name, GX_WIDGET *parent, GX_WIDGET **new_widget)\n"
"{\n"
"    UINT status = GX_FAILURE;\n"
"    GX_CONST GX_STUDIO_WIDGET_ENTRY *entry = %s_widget_table;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"\n"
"    while(entry->widget_information)\n"
"    {\n"
"        if (!strcmp(name, entry->widget_information->widget_name))\n"
"        {\n"
"            widget = gx_studio_widget_create((GX_BYTE *) entry->widget, entry->widget_information, parent);\n"
"            if (widget)\n"
"            {\n"
"                status = GX_SUCCESS;\n"
"            }\n"   
"            break;\n"
"        }\n"
"        entry++;\n"
"    }\n"
"\n"
"    if (new_widget)\n"
"    {\n"
"        *new_widget = widget;\n"
"    }\n"
"    return status;\n"
"}\n" 
"\n";


char *widget_loaders_525 = "\n"
"GX_WIDGET *gx_studio_widget_create(GX_BYTE *control, GX_CONST GX_STUDIO_WIDGET *definition, GX_WIDGET *parent)\n"
"{\n"
"    UINT status = GX_SUCCESS;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"\n"
"    while(definition && status == GX_SUCCESS)\n"
"    {\n"
"        if (definition->create_function)\n"
"        {\n"
"            if (definition->style & GX_STYLE_DYNAMICALLY_ALLOCATED)\n"
"            {\n"
"                status = gx_widget_allocate(&widget, definition->control_block_size);\n"
"                if (status != GX_SUCCESS)\n"
"                {\n"
"                    return GX_NULL;\n"
"                }\n"
"            }\n"
"            else\n"
"            {\n"
"                if(!control)\n"
"                {\n"
"                    return GX_NULL;\n"
"                }\n"
"\n"
"                widget = (GX_WIDGET *) (control + definition->control_block_offset);\n"
"            }\n"
"\n"
"            status = definition->create_function(definition, widget, parent);\n"
"\n"
"            if (status == GX_SUCCESS)\n"
"            {\n"
"                gx_widget_fill_color_set(widget, definition->normal_fill_color_id, definition->selected_fill_color_id);\n"
"\n"
"                if (!(definition->status & GX_STATUS_ACCEPTS_FOCUS))\n"
"                {\n"
"                    gx_widget_status_remove(widget, GX_STATUS_ACCEPTS_FOCUS);\n"
"                }\n"
"\n"
"                if (definition->draw_function)\n"
"                {\n"
"                    gx_widget_draw_set(widget, definition->draw_function);\n"
"                }\n"
"                if (definition->event_function)\n"
"                {\n"
"                    gx_widget_event_process_set(widget, definition->event_function);\n"
"                }\n"
"\n"
"                if (definition->child_widget)\n"
"                {\n"
"                    gx_studio_widget_create(control, definition->child_widget, widget);\n"
"                }\n"
"            }\n"
"            definition = definition->next_widget;\n"
"        }\n"
"    }\n"
"    return widget;\n"
"}\n"
"\n"
"\n"
"UINT gx_studio_named_widget_create(char *name, GX_WIDGET *parent, GX_WIDGET **new_widget)\n"
"{\n"
"    UINT status = GX_FAILURE;\n"
"    GX_CONST GX_STUDIO_WIDGET_ENTRY *entry = %s_widget_table;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"\n"
"    while(entry->widget_information)\n"
"    {\n"
"        if (!strcmp(name, entry->widget_information->widget_name))\n"
"        {\n"
"            widget = gx_studio_widget_create((GX_BYTE *) entry->widget, entry->widget_information, parent);\n"
"            if (widget)\n"
"            {\n"
"                status = GX_SUCCESS;\n"
"            }\n"
"            break;\n"
"        }\n"
"        entry++;\n"
"    }\n"
"\n"
"    if (new_widget)\n"
"    {\n"
"        *new_widget = widget;\n"
"    }\n"
"    return status;\n"
"}\n"
"\n";


///////////////////////////////////////////////////////////////////////////////
char *widget_loaders_50 = "\n"
"GX_WIDGET *gx_studio_widget_create(GX_STUDIO_WIDGET *definition, GX_WIDGET *parent)\n"
"{\n"
"    UINT status = GX_SUCCESS;\n"
"    GX_WIDGET *widget = GX_NULL;\n"
"\n"
"    while(definition && status == GX_SUCCESS)\n"
"    {\n"
"        if (definition->create_function)\n"
"        {\n"
"            widget = definition->control_block;\n"
"            status = definition->create_function(definition, widget, parent);\n"
"\n"
"            if (status == GX_SUCCESS)\n"
"            {\n"
"                gx_widget_fill_color_set(widget, definition->normal_fill_color_id, definition->selected_fill_color_id);\n"
"\n"
"                if (!(definition->status & GX_STATUS_ACCEPTS_FOCUS))\n"
"                {\n"
"                    gx_widget_status_remove(widget, GX_STATUS_ACCEPTS_FOCUS);\n"
"                }\n"
"\n"
"                if (definition->draw_function)\n"
"                {\n"
"                    gx_widget_draw_set(widget, definition->draw_function);\n"
"                }\n"
"                if (definition->event_function)\n"
"                {\n"
"                    gx_widget_event_process_set(widget, definition->event_function);\n"
"                }\n"
"                if (definition->child_widget)\n"
"                {\n"
"                    gx_studio_widget_create(definition->child_widget, widget);\n"
"                }\n"
"            }\n"
"        }\n"
"        definition = definition->next_widget;\n"
"    }\n"
"    return widget;\n"
"}\n"

"\n"
"UINT gx_studio_named_widget_create(char *name, GX_WIDGET *parent, GX_WIDGET **new_widget)\n"
"{\n"
"    UINT status = GX_FAILURE;\n"
"    UINT index = 0;\n"
"    GX_STUDIO_WIDGET *entry;\n"
"    GX_WIDGET *control_block = GX_NULL;\n"
"\n"
"    while(1)\n"
"    {\n"
"        entry =  %s_widget_table[index];\n"
"        if (!entry)\n"
"        {\n"
"            break;\n"
"        }\n"
"        if (!strcmp(name, entry->widget_name))\n"
"        {\n"
"            control_block = gx_studio_widget_create(0, entry, parent);\n"
"            break;\n"
"        }\n"
"        index++;\n"
"    }\n"
"\n"
"    if (new_widget)\n"
"    {\n"
"        *new_widget = control_block;\n"
"    }\n"
"    if (control_block != GX_NULL)\n"
"    {\n"
"        status = GX_SUCCESS;\n"
"    }\n"
"\n"
"    return status;\n"
"}\n" 
"\n";


///////////////////////////////////////////////////////////////////////////////
void screen_generator::DeclareWidgetTable()
{
    CString out("");
    char *loader_string;
    int display;
    folder_info *folder;
    widget_info *info;
    CString display_name;

    /* Define widget table. */
    if (m_project->mHeader.guix_version < 50100)
    {
        out.Format(_T("GX_STUDIO_WIDGET_ENTRY %s_widget_table[] =\n{\n"), m_project->mHeader.project_name);
    }
    else
    {
        out.Format(_T("GX_CONST GX_STUDIO_WIDGET_ENTRY %s_widget_table[] =\n{\n"), m_project->mHeader.project_name);
    }
    FileWrite(out);

    for (display = 0; display < m_project->mHeader.num_displays; display++)
    {
        folder = m_project->mDisplays[display].GetFirstChildFolder();

        display_name.Format(_T(""));
        if (m_project->mHeader.num_displays > 1)
        {
            display_name = m_project->mDisplays[display].name + _T("_");
        }

        while (folder)
        {
            info = folder->GetFirstChildWidget();
            while (info)
            {
                if (m_project->mHeader.guix_version < 50100)
                {
                    out.Format(_T("    { &%s_define, (GX_WIDGET *) &%s },\n"), info->app_name, info->app_name);
                    FileWrite(out);
                }
                else
                {
                    if (info->is_template == FALSE)
                    {
                        if (info->allocation == STATICALLY_ALLOCATED)
                        {
                            out.Format(_T("    { &%s%s_define, (GX_WIDGET *) &%s%s },\n"), display_name, info->app_name, display_name, info->app_name);
                        }
                        else
                        {
                            out.Format(_T("    { &%s%s_define, GX_NULL },\n"), display_name, info->app_name);
                        }
                        FileWrite(out);
                    }
                }
                info = info->GetNextWidgetInfo();
            }
            folder = folder->GetNextFolder();
        }

    }
    FileWrite(CString("    {GX_NULL, GX_NULL}\n};\n"));

    if (m_project->mHeader.guix_version < 50100)
    {
        loader_string = widget_loaders_50;
    }
    else
    {
        if (m_project->mHeader.guix_version < 50206)
        {
            loader_string = widget_loaders_525;
        }
        else if (m_project->mHeader.guix_version < 50300)
        {
            loader_string = widget_loaders_52;
        }
        else if (m_project->mHeader.guix_version < 50400)
        {
            loader_string = widget_loaders_53;
        }
        else if (m_project->mHeader.guix_version < 50402)
        {
            loader_string = widget_loaders_54;
        }
        else
        {
            loader_string = widget_loaders_542;
        }
    }
    out.Format(CA2T(loader_string), m_project->mHeader.project_name, m_project->mHeader.project_name);
    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
ULONG screen_generator::CalculateCanvasSizeBytes(int display)
{
    ULONG bytes = m_project->mDisplays[display].xres;

    switch(m_project->mDisplays[display].bits_per_pix)
    {
    case 1:
        bytes += 7;
        bytes /= 8;
        break;
       
    case 2:
        bytes += 3;
        bytes /= 4;
        break;

    case 4:
        bytes++;
        bytes /= 2;
        break;

    case 8:
        break;

    case 16:
        bytes *= 2;
        break;

    case 24:
        //bytes *= 3;
        // for now only supporting unpacked format:
        bytes *= 4;
        break;

    case 32:
        bytes *= 4;
        break;
    }
    bytes *= m_project->mDisplays[display].yres;
    return bytes;
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::DeclareDisplayTable()
{
    CString out;

    int display;
    int xres;
    int yres;
    CString display_name;
    CString upper_display_name;
    CString theme_table_name;
    CString language_table_name;
    CString language_direction_table_name;
    CString theme_table_size;
    CString language_table_size;
    CString string_table_size;

    CCommandInfo *pCmdInfo = GetCmdInfo();

    for (display = 0; display < m_project->mHeader.num_displays; display++)
    {
        display_name = m_project->mDisplays[display].name;

        if (m_project->CountStaticallyDefinedThemes(display))
        {
            out.Format(_T("extern GX_CONST GX_THEME *%s_theme_table[];\n"), display_name);
            FileWrite(out);
        }


        if (m_project->CountStaticallyDefinedLanguages())
        {
            if (project_lib_version() < GX_VERSION_STRING_LENGTH_FIX)
            {
                out.Format(_T("extern GX_CONST GX_CHAR **%s_language_table[];\n"), display_name);
            }
            else
            {
                out.Format(_T("extern GX_CONST GX_STRING *%s_language_table[];\n"), display_name);
            }

            FileWrite(out);

            if (string_table::TestGenerateLanguageDirectionTable())
            {
                out.Format(_T("extern GX_CONST GX_UBYTE %s_language_direction_table[];\n"), display_name);
                FileWrite(out);
            }
        }
    }

    out.Format(_T("\nGX_STUDIO_DISPLAY_INFO %s_display_table[%d] =\n{\n"), m_project->mHeader.project_name, m_project->mHeader.num_displays);
    FileWrite(out);

    for (display = 0; display < m_project->mHeader.num_displays; display++)
    {
        display_name = m_project->mDisplays[display].name;
        upper_display_name = display_name;
        upper_display_name.MakeUpper();

        xres = m_project->mDisplays[display].xres;
        yres = m_project->mDisplays[display].yres;

        if (m_project->mDisplays[display].rotation_angle == GX_SCREEN_ROTATION_CW ||
            m_project->mDisplays[display].rotation_angle == GX_SCREEN_ROTATION_CCW)
        {
            GX_SWAP_VALS(xres, yres);
        }

        if (m_project->mHeader.guix_version <= 50302)
        {
            out.Format(_T("    {\n")
                _T("    \"%s\",\n")
                _T("    \"%s_canvas\",\n")
                _T("    %s_theme_table,\n")
                _T("    %s_language_table,\n")
                _T("    %s_LANGUAGE_TABLE_SIZE,\n")
                _T("    %s_STRING_TABLE_SIZE,\n")
                _T("    %d, /* x resolution */\n")
                _T("    %d, /* y resolution */\n")
                _T("    &%s_control_block,\n")
                _T("    &%s_canvas_control_block,\n")
                _T("    &%s_root_window,\n"),
                display_name,
                display_name,
                display_name,
                display_name,
                upper_display_name,
                upper_display_name,
                xres,
                yres,
                display_name,
                display_name,
                display_name);
        }
        else
        {
            if (m_project->CountStaticallyDefinedThemes(display))
            {
                theme_table_name.Format(_T("%s_theme_table"), display_name);
                theme_table_size.Format(_T("%s_THEME_TABLE_SIZE"), upper_display_name);
            }
            else
            {
                theme_table_name = _T("GX_NULL");
                theme_table_size = _T("0");
            }

            if (m_project->CountStaticallyDefinedLanguages())
            {
                language_table_name.Format(_T("%s_language_table"), display_name);
                language_table_size.Format(_T("%s_LANGUAGE_TABLE_SIZE"), upper_display_name);
                string_table_size.Format(_T("%s_STRING_TABLE_SIZE"), upper_display_name);
            }
            else
            {
                language_table_name = _T("GX_NULL");
                language_table_size = _T("0");
                string_table_size = _T("0");
            }

            if (string_table::TestGenerateLanguageDirectionTable())
            {
                language_direction_table_name.Format(_T("    %s_language_direction_table,\n"), display_name);
            }
            else
            {
                language_direction_table_name = _T("");
            }

            if (m_project->mHeader.guix_version < GX_VERSION_STRING_LENGTH_FIX)
            {
                out.Format(_T("    {\n")
                    _T("    \"%s\",\n")
                    _T("    \"%s_canvas\",\n")
                    _T("    %s,\n")
                    _T("    %s,\n")
                    _T("    %s,\n")
                    _T("    %s,\n")
                    _T("    %s,\n")
                    _T("    %d, /* x resolution */\n")
                    _T("    %d, /* y resolution */\n")
                    _T("    &%s_control_block,\n")
                    _T("    &%s_canvas_control_block,\n")
                    _T("    &%s_root_window,\n"),
                    display_name,
                    display_name,
                    theme_table_name,
                    language_table_name,
                    theme_table_size,
                    language_table_size,
                    string_table_size,
                    xres,
                    yres,
                    display_name,
                    display_name,
                    display_name);
            }
            else
            {
                out.Format(_T("    {\n")
                    _T("    \"%s\",\n")
                    _T("    \"%s_canvas\",\n")
                    _T("    %s,\n")
                    _T("    %s,\n")
                    _T("%s")
                    _T("    %s,\n")
                    _T("    %s,\n")
                    _T("    %s,\n")
                    _T("    %d, /* x resolution */\n")
                    _T("    %d, /* y resolution */\n")
                    _T("    &%s_control_block,\n")
                    _T("    &%s_canvas_control_block,\n")
                    _T("    &%s_root_window,\n"),
                    display_name,
                    display_name,
                    theme_table_name,
                    language_table_name,
                    language_direction_table_name,
                    theme_table_size,
                    language_table_size,
                    string_table_size,
                    xres,
                    yres,
                    display_name,
                    display_name,
                    display_name);
            }
        }

        FileWrite(out);

        if (m_project->mDisplays[display].allocate_canvas)
        {
            out.Format(_T("    %s_canvas_memory, /* canvas memory area */\n"),
                display_name);
            FileWrite(out);
        }
        else
        {
            FileWrite(CString("    GX_NULL, /* canvas memory area */\n"));
        }

        if (project_lib_version() >= GX_VERSION_DISPLAY_ROTATION)
        {
            CString rotation;
            switch (m_project->mDisplays[display].rotation_angle)
            {
            case GX_SCREEN_ROTATION_CW:
                rotation = _T("GX_SCREEN_ROTATION_CW");
                break;

            case GX_SCREEN_ROTATION_CCW:
                rotation = _T("GX_SCREEN_ROTATION_CCW");
                break;

            case GX_SCREEN_ROTATION_FLIP:
                if (project_lib_version() >= GX_VERSION_SCREEN_ROTATION_DEFS)
                {
                    rotation = _T("GX_SCREEN_ROTATION_FLIP");
                }
                else
                {
                    rotation = _T("180");
                }
                break;

            default:
                if (project_lib_version() >= GX_VERSION_SCREEN_ROTATION_DEFS)
                {
                    rotation = _T("GX_SCREEN_ROTATION_NONE");
                }
                else
                {
                    rotation = _T("0");
                }
                break;
            }
            out.Format(_T("    %d,  /* canvas memory size in bytes */\n")
                _T("    %s  /* rotation angle */\n")
                _T("    }"),
                CalculateCanvasSizeBytes(display), rotation);
        }
        else
        {
            out.Format(_T("    %d  /* canvas memory size in bytes */\n")
                _T("    }"),
                CalculateCanvasSizeBytes(display));
        }

        FileWrite(out);
        if (display < m_project->mHeader.num_displays - 1)
        {
            FileWrite(CString(",\n"));
        }
        else
        {
            FileWrite(CString("\n"));
        }
    }
    FileWrite(CString("};\n\n"));
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::DeclareBaseMembers(widget_info *info)
{
    CString out;
    CString upper_name;
    widget_service_provider *provider = widget_factory::GetServiceProvider(info->basetype);

    if (provider)
    {
        if (info->basetype == GX_TYPE_TEMPLATE)
        {
            template_service_provider *tp = (template_service_provider *) provider;
            widget_info *base = tp->GetBaseInfo(info);
            
            if (base)
            {
                /* declare an instance of the base control block type */
                upper_name = m_screen_name_prefix + base->app_name;
                upper_name.MakeUpper();
                out.Format(_T("    %s_CONTROL_BLOCK base;\n"), upper_name);
                FileWrite(out);
            }
        }
        else
        {
            out.Format(_T("    %s\n"), provider->GetVarDeclaration());
            FileWrite(out);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::DeclareChildMembers(CString &parent_name, widget_info *info)
{
    CString out;

    while(info)
    {
        if (m_project->mHeader.guix_version < 50100 || 
            info->allocation == STATICALLY_ALLOCATED)
        {
            if (info->basetype == GX_TYPE_TEMPLATE)
            {
                CString cbname = m_screen_name_prefix + info->base_name;
                cbname.MakeUpper();

                /* a child template. The control block type is app_name */
                out.Format(_T("    %s_CONTROL_BLOCK %s_%s;\n"), cbname, parent_name, info->app_name);
                FileWrite(out);
            }
            else
            {
                widget_service_provider *provider = widget_factory::GetServiceProvider(info->basetype);

                if (provider)
                {
                    out.Format(_T("    %s %s_%s;\n"), provider->GetControlBlockName(), parent_name, info->app_name);
                    FileWrite(out);
                }
            }
        }

        if (info->GetChildWidgetInfo())
        {
            DeclareChildMembers(parent_name, info->GetChildWidgetInfo());
        }
        info = info->GetNextWidgetInfo();
    }
}


///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteWidgetProperties(CString &prefix, widget_info *info, BOOL TopLevel)
{
    CString scope_name("");

    if (TopLevel)
    {
        CString app_name = _T("_") + info->app_name;
        scope_name = prefix.Left(prefix.GetLength() - app_name.GetLength());
    }
    else
    {
        scope_name = prefix;
    }

    while(info)
    {
        widget_service_provider *provider = widget_factory::GetServiceProvider(info->basetype);

        if (provider)
        {
            CString write_string = provider->WriteExtendedProperties(this, scope_name, info);
            if (!write_string.IsEmpty())
            {
                FileWrite(write_string);
            }
        }
        
        if (info->GetChildWidgetInfo())
        {            
            WriteWidgetProperties(prefix, info->GetChildWidgetInfo());
        }

        if (TopLevel)
        {
            info = NULL;
        }
        else
        {
            info = info->GetNextWidgetInfo();
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetColorIdName(studiox_project *project, int display, int color_id)
{
    CString val("0");

    int active_theme = project->mDisplays[display].active_theme;
    res_info *info = project->FindResource(display, active_theme, RES_TYPE_COLOR, color_id);

    if (info)
    {
        CString upper_name("");

        if (!info->is_default && project->mHeader.num_displays > 1)
        {
            upper_name += project ->mDisplays[display].name;
            upper_name += "_";
        }
        upper_name += info->name;
        upper_name.MakeUpper();
        val = CString("GX_COLOR_ID_") + upper_name;
    }
    return val;
}
///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetColorIdName(int color_id) const
{
    return GetColorIdName(m_project, m_display, color_id);
}

///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetFontIdName(studiox_project *project, int display, int font_id)
{
    CString val("0");
    int active_theme = project->mDisplays[display].active_theme;
    res_info *info = project->FindResource(display, active_theme, RES_TYPE_FONT, font_id);

    if (info)
    {
        CString upper_name("");

        if (!info->is_default && project->mHeader.num_displays > 1)
        {
            upper_name += project ->mDisplays[display].name;
            upper_name += "_";
        }        
        upper_name += info->name;
        upper_name.MakeUpper();
        val = CString("GX_FONT_ID_") + upper_name;
    }
    return val;
}
///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetFontIdName(int font_id) const
{
    return GetFontIdName(m_project, m_display, font_id);
}

///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetPixelmapIdName(studiox_project *proj, int display, int pixelmap_id, int frame_id)
{
    CString val("0");
    if (proj)
    {
        int active_theme = proj->mDisplays[display].active_theme;

        res_info *info = proj->FindResource(display, active_theme, RES_TYPE_PIXELMAP, pixelmap_id);

        if (info)
        {
            CString upper_name("");

            if (!info->is_default &&
                (proj->mHeader.num_displays > 1))
            {
                upper_name += proj->mDisplays[display].name;
                upper_name += "_";
            }
            upper_name += MakePixelmapName(info, frame_id);
            upper_name.MakeUpper();
            val = CString("GX_PIXELMAP_ID_") + upper_name;
        }
    }
    return val;
}

///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetString(int string_id, int language) const
{
    string_table *table = m_project->mDisplays[m_display].stable;

    if (table)
    {
        CString id_name = table->GetResourceIdName(string_id);
        return table->GetString(id_name, language);
    }

    return _T("");
}

///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetPixelmapIdName(int pixelmap_id, int frame_id) const
{
    return GetPixelmapIdName(m_project, m_display, pixelmap_id, frame_id);
}

///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetStringIdName(studiox_project *proj, int display, int string_id, widget_info *info)
{
    CString val("0");

    if (string_id)
    {
        string_table *pt = proj->mDisplays[display].stable;
    
        if (pt)
        {
            CString id_name = pt->GetResourceIdName(string_id, info);

            if (!id_name.IsEmpty())
            {
                CString upper_name("");

                if (proj->mHeader.num_displays > 1)
                {
                    upper_name += proj->mDisplays[display].name;
                    upper_name += "_";
                    upper_name.MakeUpper();
                }
                upper_name += id_name;

                val = CString("GX_STRING_ID_") + upper_name;
            }
        }
    }
    return val;
}

///////////////////////////////////////////////////////////////////////////////
CString screen_generator::GetStringIdName(int string_id, widget_info *info) const
{
    return GetStringIdName(m_project, m_display, string_id, info);
}
///////////////////////////////////////////////////////////////////////////////
BOOL screen_generator::IsWidgetUsed(widget_info *start, int type) const
{
    BOOL status = FALSE;
    while(start)
    {
        if (start->basetype == type)
        {
            return TRUE;
        }
        if (start->GetChildWidgetInfo())
        {
            status = IsWidgetUsed(start->GetChildWidgetInfo(), type);
            if (status)
            {
                return status;
            }
        }
        start = start->GetNextWidgetInfo();
    }
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
BOOL screen_generator::IsWidgetUsed(int type) const
{
    int display;

    for (display = 0; display < m_project->mHeader.num_displays; display++)
    {
        folder_info *info = m_project->mDisplays[display].GetFirstChildFolder();

        while (info)
        {
            if (IsWidgetUsed(info->GetFirstChildWidget(), type))
            {
                return TRUE;
            }
            info = info->GetNextFolder();
                
        }
    }
    return FALSE;   
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteCreateFunctions()
{
    int index = 0;
    int version = m_project->mHeader.guix_version;

    while(1)
    {
        int widget_type = widget_factory::GetWidgetType(index);

        if (!widget_type)
        {
            break;
        }
        if (IsWidgetUsed(widget_type))
        {
            widget_service_provider *provider = widget_factory::GetServiceProvider(widget_type);
            if (provider)
            {
                FileWrite(provider->GetCreateFromDefFunction(version));
            }
        }
        index++;
    }
} 


///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteDave2D8bppPaletteSetup()
{
    CString out;
    CString toggle_func;
    /* perform standard GUIX setup */

    if (IsRenesasDave2D(m_project))
    {
        toggle_func = " _gx_dave2d_buffer_toggle_8bpp);\n";
    }
    else
    {
        switch(m_project->mHeader.target_cpu)
        {
        case CPU_RA:
            toggle_func = " _gx_ra_buffer_toggle_8bpp);\n";
            break;

        case CPU_RX:
            toggle_func = " _gx_rx_buffer_toggle_8bpp);\n";
            break;

        default:        // synergy
            toggle_func = " _gx_synergy_buffer_toggle_8bpp);\n";
            break;
        }
    }
    out = "    _gx_display_driver_8bit_palette_setup(display, GX_NULL,";
    out += toggle_func;

    out += "    display->gx_display_handle =    0;\n";
    out += "    display -> gx_display_driver_palette_set = _gx_display_driver_8bit_palette_assign;\n";

     /* override drawing functions if using Dave2D accelerator */

    if (IsRenesasDave2D(m_project))
    {
        out += "    display -> gx_display_driver_drawing_initiate              = _gx_dave2d_drawing_initiate_8bpp;\n";
        out += "    display -> gx_display_driver_drawing_complete              = _gx_dave2d_drawing_complete_8bpp;\n";
        out += "    display -> gx_display_driver_horizontal_pattern_line_draw  = _gx_dave2d_horizontal_pattern_line_draw_8bpp;\n";
        out += "    display -> gx_display_driver_vertical_pattern_line_draw    = _gx_dave2d_vertical_pattern_line_draw_8bpp;\n";
        out += "    display -> gx_display_driver_pixel_write                   = _gx_dave2d_pixel_write_8bpp;\n";
        out += "    display -> gx_display_driver_canvas_copy                   = _gx_dave2d_canvas_copy;\n";
        out += "    display -> gx_display_driver_simple_line_draw              = _gx_dave2d_simple_line_draw_8bpp;\n";
        out += "    display -> gx_display_driver_horizontal_line_draw          = _gx_dave2d_horizontal_line_8bpp;\n";
        out += "    display -> gx_display_driver_vertical_line_draw            = _gx_dave2d_vertical_line_8bpp;\n";
        out += "    display -> gx_display_driver_polygon_draw                  = _gx_dave2d_polygon_draw_8bpp;\n";
        out += "    display -> gx_display_driver_polygon_fill                  = _gx_dave2d_polygon_fill_8bpp;\n";
        out += "    display -> gx_display_driver_block_move                    = _gx_dave2d_block_move_8bpp;\n";
        out += "    display -> gx_display_driver_pixelmap_draw                 = _gx_dave2d_pixelmap_draw_8bpp;\n";
        out += "    display -> gx_display_driver_simple_wide_line_draw         = _gx_dave2d_simple_wide_line_8bpp;\n";

        out += "    display -> gx_display_driver_1bit_glyph_draw               = _gx_dave2d_glyph_1bit_draw_8bpp;\n";
        if (project_lib_version() >= GX_VERSION_SYNERGY_GLYPH_GEN_CHANGE)
        {
            out += "#if(GX_PALETTE_MODE_AA_TEXT_COLORS == 8)\n";
            out += "    display -> gx_display_driver_4bit_glyph_draw               = _gx_dave2d_glyph_3bit_draw_8bpp;\n";
            out += "#else\n";
        }
        out += "    display -> gx_display_driver_4bit_glyph_draw               = _gx_dave2d_glyph_4bit_draw_8bpp;\n";

        if (project_lib_version() >= GX_VERSION_SYNERGY_GLYPH_GEN_CHANGE)
        {
            out += "#endif\n";
        }

        out += "    #if defined(GX_ARC_DRAWING_SUPPORT)\n";
        out += "    display -> gx_display_driver_circle_draw                   = _gx_dave2d_circle_draw_8bpp;\n";
        out += "    display -> gx_display_driver_circle_fill                   = _gx_dave2d_circle_fill_8bpp;\n";
        out += "    display -> gx_display_driver_pie_fill                      = _gx_dave2d_pie_fill_8bpp;\n";
        out += "    display -> gx_display_driver_arc_draw                      = _gx_dave2d_arc_draw_8bpp;\n";
        out += "    display -> gx_display_driver_arc_fill                      = _gx_dave2d_arc_fill_8bpp;\n";
        out += "    display -> gx_display_driver_ellipse_draw                  = _gx_dave2d_ellipse_draw_8bpp;\n";
        out += "    display -> gx_display_driver_ellipse_fill                  = _gx_dave2d_ellipse_fill_8bpp;\n";
        if (project_lib_version() > 50500)
        {
            out += "    display -> gx_display_driver_wide_circle_draw              = _gx_dave2d_circle_draw_8bpp;\n";
            out += "    display -> gx_display_driver_wide_arc_draw                 = _gx_dave2d_arc_draw_8bpp;\n";
            out += "    display -> gx_display_driver_wide_ellipse_draw             = _gx_dave2d_wide_ellipse_draw_8bpp;\n";
        }
        out += "    #endif\n";
    }

    if (m_project->mHeader.renesas_jpeg_decoder == DECODER_TYPE_HW)
    {
        if (m_project->mHeader.target_cpu == CPU_SYNERGY)
        {
            out += "    display -> gx_display_driver_jpeg_draw                     = _gx_synergy_jpeg_draw;\n";
        }
        else
        {
            out += "    display -> gx_display_driver_jpeg_draw                     = _gx_renesas_jpeg_draw;\n";
        }
    }
    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteDave2D8bppPaletteRotatedSetup()
{
    CString out;
    CString toggle_func("");

    /* perform standard GUIX setup */

    if (IsRenesasDave2D(m_project))
    {
        toggle_func = " _gx_dave2d_rotated_buffer_toggle_8bpp);\n";
    }
    else
    {    
        switch (m_project->mHeader.target_cpu)
        {
        case CPU_RA:
            toggle_func = " _gx_ra_rotated_buffer_toggle_8bpp);\n";
            break;

        case CPU_RX:
            toggle_func = " _gx_rx_rotated_buffer_toggle_8bpp);\n";
            break;

        default:        // synergy
            toggle_func = " _gx_synergy_rotated_buffer_toggle_8bpp);\n";
            break;
        }
    }

    out = "    _gx_display_driver_8bit_palette_rotated_setup(display, GX_NULL,";
    out += toggle_func;

    out += "    display -> gx_display_handle                               = 0;\n";
    out += "    display -> gx_display_driver_palette_set                   = _gx_display_driver_8bit_palette_assign;\n";

    /* override drawing functions if using Dave2D accelerator */

    if (IsRenesasDave2D(m_project))
    {
        out += "    display -> gx_display_driver_drawing_initiate              = _gx_dave2d_drawing_initiate_8bpp;\n";
        out += "    display -> gx_display_driver_drawing_complete              = _gx_dave2d_drawing_complete_8bpp;\n";
        out += "    display -> gx_display_driver_horizontal_pattern_line_draw  = _gx_dave2d_rotated_horizontal_pattern_line_draw_8bpp;\n";
        out += "    display -> gx_display_driver_vertical_pattern_line_draw    = _gx_dave2d_rotated_vertical_pattern_line_draw_8bpp;\n";
        out += "    display -> gx_display_driver_pixel_write                   = _gx_dave2d_rotated_pixel_write_8bpp;\n";
        out += "    display -> gx_display_driver_canvas_copy                   = _gx_dave2d_rotated_canvas_copy;\n";
        out += "    display -> gx_display_driver_simple_line_draw              = _gx_dave2d_rotated_simple_line_draw_8bpp;\n";
        out += "    display -> gx_display_driver_horizontal_line_draw          = _gx_dave2d_rotated_horizontal_line_8bpp;\n";
        out += "    display -> gx_display_driver_vertical_line_draw            = _gx_dave2d_rotated_vertical_line_8bpp;\n";
        out += "    display -> gx_display_driver_polygon_draw                  = _gx_dave2d_rotated_polygon_draw_8bpp;\n";
        out += "    display -> gx_display_driver_polygon_fill                  = _gx_dave2d_rotated_polygon_fill_8bpp;\n";
        out += "    display -> gx_display_driver_block_move                    = _gx_dave2d_rotated_block_move_8bpp;\n";
        out += "    display -> gx_display_driver_pixelmap_draw                 = _gx_dave2d_rotated_pixelmap_draw_8bpp;\n";
        out += "    display -> gx_display_driver_simple_wide_line_draw         = _gx_dave2d_rotated_simple_wide_line_8bpp;\n";
        out += "    display -> gx_display_driver_1bit_glyph_draw               = _gx_dave2d_rotated_glyph_1bit_draw_8bpp;\n";
        out += "#if(GX_PALETTE_MODE_AA_TEXT_COLORS == 8)\n";
        out += "    display -> gx_display_driver_4bit_glyph_draw               = _gx_dave2d_rotated_glyph_3bit_draw_8bpp;\n";
        out += "#else\n";
        out += "    display -> gx_display_driver_4bit_glyph_draw               = _gx_dave2d_rotated_glyph_4bit_draw_8bpp;\n";
        out += "#endif\n";
        out += "    #if defined(GX_ARC_DRAWING_SUPPORT)\n";
        out += "    display -> gx_display_driver_circle_draw                   = _gx_dave2d_rotated_circle_draw_8bpp;\n";
        out += "    display -> gx_display_driver_circle_fill                   = _gx_dave2d_rotated_circle_fill_8bpp;\n";
        out += "    display -> gx_display_driver_pie_fill                      = _gx_dave2d_rotated_pie_fill_8bpp;\n";
        out += "    display -> gx_display_driver_arc_draw                      = _gx_dave2d_rotated_arc_draw_8bpp;\n";
        out += "    display -> gx_display_driver_arc_fill                      = _gx_dave2d_rotated_arc_fill;\n";
        out += "    display -> gx_display_driver_ellipse_draw                  = _gx_dave2d_rotated_ellipse_draw;\n";
        out += "    display -> gx_display_driver_ellipse_fill                  = _gx_dave2d_rotated_ellipse_fill;\n";
        out += "    display -> gx_display_driver_wide_circle_draw              = _gx_dave2d_rotated_circle_draw_8bpp;\n";
        out += "    display -> gx_display_driver_wide_arc_draw                 = _gx_dave2d_rotated_arc_draw_8bpp;\n";
        out += "    display -> gx_display_driver_wide_ellipse_draw             = _gx_dave2d_rotated_ellipse_draw;\n";
        out += "    #endif\n";
    }
    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteDave2D16_32_Setup(UINT color_format)
{
    CString out("");
    CString toggle_func("");

    if (IsRenesasDave2D(m_project))
    {
        toggle_func = " _gx_dave2d_buffer_toggle);\n";
    }
    else
    {
        switch (m_project->mHeader.target_cpu)
        {
        case CPU_RA:
            toggle_func = " _gx_ra_buffer_toggle);\n";
            break;

        case CPU_RX:
            toggle_func = " _gx_rx_buffer_toggle);\n";
            break;

        default:        // synergy
            toggle_func = " _gx_synergy_buffer_toggle);\n";
            break;
        }
    }

    /* perform standard GUIX setup */
    if (color_format == GX_COLOR_FORMAT_565RGB)
    {
        out += "    _gx_display_driver_565rgb_setup(display, GX_NULL,";
        out += toggle_func;
    }
    else
    {
        if (IsRenesasDave2D(m_project))
        {
            out += "    _gx_display_driver_32argb_setup(display, GX_NULL,";
        }
        else
        {
            if (color_format == GX_COLOR_FORMAT_24XRGB)
            {
                out += "    _gx_display_driver_24xrgb_setup(display, GX_NULL,";
            }
            else
            {
                out += "    _gx_display_driver_32argb_setup(display, GX_NULL,";
            }
        }
        out += toggle_func;
    }
    out += "    display->gx_display_handle =    0;\n";

    /* override drawing functions if using Dave2D accelerator */

    if (IsRenesasDave2D(m_project))
    {
        if (color_format == GX_COLOR_FORMAT_565RGB)
        {
            out += "    display -> gx_display_driver_horizontal_pattern_line_draw  = _gx_dave2d_horizontal_pattern_line_draw_565;\n";
            out += "    display -> gx_display_driver_vertical_pattern_line_draw    = _gx_dave2d_vertical_pattern_line_draw_565;\n";
            out += "    display -> gx_display_driver_pixel_write                   = _gx_dave2d_pixel_write_565;\n";
            out += "    display -> gx_display_driver_pixel_blend                   = _gx_dave2d_pixel_blend_565;\n";
            if (m_project->mHeader.guix_version > 50303)
            {
                out += "    display -> gx_display_driver_pixelmap_rotate               = _gx_dave2d_pixelmap_rotate_16bpp;\n";
            }
        }
        else
        {
            out += "    display -> gx_display_driver_horizontal_pattern_line_draw  = _gx_dave2d_horizontal_pattern_line_draw_888;\n";
            out += "    display -> gx_display_driver_vertical_pattern_line_draw    = _gx_dave2d_vertical_pattern_line_draw_888;\n";
            out += "    display -> gx_display_driver_pixel_write                   = _gx_dave2d_pixel_write_888;\n";
            out += "    display -> gx_display_driver_pixel_blend                   = _gx_dave2d_pixel_blend_888;\n";
        }

        // override those functions for which we are going to provide accelerated implementations
        out += "    display -> gx_display_driver_drawing_initiate              = _gx_dave2d_drawing_initiate;\n";
        out += "    display -> gx_display_driver_drawing_complete              = _gx_dave2d_drawing_complete;\n";

        out += "    display -> gx_display_driver_canvas_copy                   = _gx_dave2d_canvas_copy;\n";
        out += "    display -> gx_display_driver_canvas_blend                  = _gx_dave2d_canvas_blend;\n";
        out += "    display -> gx_display_driver_simple_line_draw              = _gx_dave2d_simple_line_draw;\n";
        out += "    display -> gx_display_driver_horizontal_line_draw          = _gx_dave2d_horizontal_line;\n";
        out += "    display -> gx_display_driver_vertical_line_draw            = _gx_dave2d_vertical_line;\n";

        out += "    display -> gx_display_driver_polygon_draw                  = _gx_dave2d_polygon_draw;\n";
        out += "    display -> gx_display_driver_polygon_fill                  = _gx_dave2d_polygon_fill;\n";

        out += "    display -> gx_display_driver_block_move                    = _gx_dave2d_block_move;\n";

        out += "    display -> gx_display_driver_pixelmap_draw                 = _gx_dave2d_pixelmap_draw;\n";
        out += "    display -> gx_display_driver_horizontal_pixelmap_line_draw = _gx_dave2d_horizontal_pixelmap_line_draw;\n";
        out += "    display -> gx_display_driver_alphamap_draw                 = _gx_dave2d_alphamap_draw;\n";
        out += "    display -> gx_display_driver_simple_wide_line_draw         = _gx_dave2d_simple_wide_line;\n";
        out += "    display -> gx_display_driver_anti_aliased_line_draw        = _gx_dave2d_aliased_line;\n";
        out += "    display -> gx_display_driver_anti_aliased_wide_line_draw   = _gx_dave2d_aliased_wide_line;\n";

        out += "    display -> gx_display_driver_pixelmap_blend                = _gx_dave2d_pixelmap_blend;\n";

        if (m_project->mHeader.guix_version < 50303)
        {
            out += "    display -> gx_display_driver_8bit_glyph_draw               = _gx_dave2d_glyph_8bit_draw;\n";
            out += "    display -> gx_display_driver_4bit_glyph_draw               = _gx_dave2d_glyph_4bit_draw;\n";
            out += "    display -> gx_display_driver_1bit_glyph_draw               = _gx_dave2d_glyph_1bit_draw;\n";
        }
        else
        {
            out += "    display -> gx_display_driver_8bit_glyph_draw               = _gx_dave2d_raw_glyph_8bit_draw;\n";
            out += "    display -> gx_display_driver_4bit_glyph_draw               = _gx_dave2d_raw_glyph_4bit_draw;\n";
            out += "    display -> gx_display_driver_1bit_glyph_draw               = _gx_dave2d_raw_glyph_1bit_draw;\n";
            out += "    display -> gx_display_driver_8bit_compressed_glyph_draw    = _gx_dave2d_compressed_glyph_8bit_draw;\n";
            out += "    display -> gx_display_driver_4bit_compressed_glyph_draw    = _gx_dave2d_compressed_glyph_4bit_draw;\n";
            out += "    display -> gx_display_driver_1bit_compressed_glyph_draw    = _gx_dave2d_compressed_glyph_1bit_draw;\n";
        }
        out += "    #if defined(GX_ARC_DRAWING_SUPPORT)\n";
        out += "    display -> gx_display_driver_anti_aliased_circle_draw      = _gx_dave2d_aliased_circle_draw;\n";
        out += "    display -> gx_display_driver_anti_aliased_wide_circle_draw = _gx_dave2d_aliased_circle_draw;\n";
        out += "    display -> gx_display_driver_circle_draw                   = _gx_dave2d_circle_draw;\n";
        out += "    display -> gx_display_driver_circle_fill                   = _gx_dave2d_circle_fill;\n";
        out += "    display -> gx_display_driver_pie_fill                      = _gx_dave2d_pie_fill;\n";
        out += "    display -> gx_display_driver_anti_aliased_arc_draw         = _gx_dave2d_aliased_arc_draw;\n";
        out += "    display -> gx_display_driver_arc_draw                      = _gx_dave2d_arc_draw;\n";
        out += "    display -> gx_display_driver_arc_fill                      = _gx_dave2d_arc_fill;\n";
        out += "    display -> gx_display_driver_anti_aliased_ellipse_draw     = _gx_dave2d_aliased_ellipse_draw;\n";
        out += "    display -> gx_display_driver_ellipse_draw                  = _gx_dave2d_ellipse_draw;\n";
        out += "    display -> gx_display_driver_ellipse_fill                  = _gx_dave2d_ellipse_fill;\n";
        out += "    display -> gx_display_driver_wide_circle_draw              = _gx_dave2d_circle_draw;\n";
        out += "    display -> gx_display_driver_anti_aliased_wide_arc_draw    = _gx_dave2d_aliased_arc_draw;\n";
        out += "    display -> gx_display_driver_wide_arc_draw                 = _gx_dave2d_arc_draw;\n";

        if (project_lib_version() > 50500)
        {
            out += "    display -> gx_display_driver_anti_aliased_wide_ellipse_draw= _gx_dave2d_aliased_ellipse_draw;\n";
            out += "    display -> gx_display_driver_wide_ellipse_draw             = _gx_dave2d_ellipse_draw;\n";
        }

        out += "    #endif\n";
    }

    if (m_project->mHeader.renesas_jpeg_decoder == DECODER_TYPE_HW)
    {
        if (m_project->mHeader.target_cpu == CPU_SYNERGY)
        {
            out += "    display -> gx_display_driver_jpeg_draw                     = _gx_synergy_jpeg_draw;\n";
        }
        else
        {
            out += "    display -> gx_display_driver_jpeg_draw                     = _gx_renesas_jpeg_draw;\n";
        }
    }


    if((m_project->mHeader.renesas_png_decoder == DECODER_TYPE_SW) &&
        IsRenesasDave2D(m_project) && (project_lib_version() >= GX_VERSION_USE_DAVE2D_PNG_DRAW))
    {
        out +="    display -> gx_display_driver_png_draw                      = _gx_dave2d_png_draw;\n";
    }

    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteDave2D16_32_RotatedSetup(UINT color_format)
{
    CString out("");
    CString toggle_func("");

    if (IsRenesasDave2D(m_project))
    {
        toggle_func = " _gx_dave2d_rotated_buffer_toggle);\n";
    }
    else
    {
        switch (m_project->mHeader.target_cpu)
        {
        case CPU_RA:
            toggle_func = " _gx_ra_rotated_buffer_toggle);\n";
            break;

        case CPU_RX:
            toggle_func = " _gx_rx_rotated_buffer_toggle);\n";
            break;

        default:        // synergy
            toggle_func = " _gx_synergy_rotated_buffer_toggle);\n";
            break;
        }
    }

    /* perform standard GUIX setup */
 
    switch(color_format)
    {
    case GX_COLOR_FORMAT_565RGB:
        out += "    _gx_display_driver_565rgb_rotated_setup(display, GX_NULL,";
        break;

    case GX_COLOR_FORMAT_24XRGB:
        out += "    _gx_display_driver_24xrgb_rotated_setup(display, GX_NULL,";
        break;

    default:
        out += "    _gx_display_driver_32argb_rotated_setup(display, GX_NULL,";
        break;
    }
    out += toggle_func;
    out += "    display->gx_display_handle =    0;\n";

    /* override drawing functions if using Dave2D accelerator */

    if (IsRenesasDave2D(m_project))
    {
        if (color_format == GX_COLOR_FORMAT_565RGB)
        {
            out += "    display -> gx_display_driver_horizontal_pattern_line_draw  = _gx_dave2d_rotated_horizontal_pattern_line_draw_565;\n";
            out += "    display -> gx_display_driver_vertical_pattern_line_draw    = _gx_dave2d_rotated_vertical_pattern_line_draw_565;\n";
            out += "    display -> gx_display_driver_pixel_write                   = _gx_dave2d_rotated_pixel_write_565;\n";
            out += "    display -> gx_display_driver_pixel_blend                   = _gx_dave2d_rotated_pixel_blend_565;\n";
            out += "    display -> gx_display_driver_pixelmap_rotate               = _gx_dave2d_rotated_pixelmap_rotate_16bpp;\n";

        }
        else
        {
            out += "    display -> gx_display_driver_horizontal_pattern_line_draw  = _gx_dave2d_rotated_horizontal_pattern_line_draw_888;\n";
            out += "    display -> gx_display_driver_vertical_pattern_line_draw    = _gx_dave2d_rotated_vertical_pattern_line_draw_888;\n";
            out += "    display -> gx_display_driver_pixel_write                   = _gx_dave2d_rotated_pixel_write_888;\n";
            out += "    display -> gx_display_driver_pixel_blend                   = _gx_dave2d_rotated_pixel_blend_888;\n";
        }

        // override those functions for which we are going to provide accelerated implementations
        out += "    display -> gx_display_driver_drawing_initiate              = _gx_dave2d_rotated_drawing_initiate;\n";
        out += "    display -> gx_display_driver_drawing_complete              = _gx_dave2d_rotated_drawing_complete;\n";

        out += "    display -> gx_display_driver_canvas_copy                   = _gx_dave2d_rotated_canvas_copy;\n";
        out += "    display -> gx_display_driver_canvas_blend                  = _gx_dave2d_rotated_canvas_blend;\n";
        out += "    display -> gx_display_driver_simple_line_draw              = _gx_dave2d_rotated_simple_line_draw;\n";
        out += "    display -> gx_display_driver_horizontal_line_draw          = _gx_dave2d_rotated_horizontal_line;\n";
        out += "    display -> gx_display_driver_vertical_line_draw            = _gx_dave2d_rotated_vertical_line;\n";

        out += "    display -> gx_display_driver_polygon_draw                  = _gx_dave2d_rotated_polygon_draw;\n";
        out += "    display -> gx_display_driver_polygon_fill                  = _gx_dave2d_rotated_polygon_fill;\n";

        out += "    display -> gx_display_driver_block_move                    = _gx_dave2d_rotated_block_move;\n";

        out += "    display -> gx_display_driver_pixelmap_draw                 = _gx_dave2d_rotated_pixelmap_draw;\n";
        out += "    display -> gx_display_driver_horizontal_pixelmap_line_draw = _gx_dave2d_rotated_horizontal_pixelmap_line_draw;\n";
        out += "    display -> gx_display_driver_alphamap_draw                 = _gx_dave2d_rotated_alphamap_draw;\n";
        out += "    display -> gx_display_driver_simple_wide_line_draw         = _gx_dave2d_rotated_simple_wide_line;\n";
        out += "    display -> gx_display_driver_anti_aliased_line_draw        = _gx_dave2d_rotated_aliased_line;\n";
        out += "    display -> gx_display_driver_anti_aliased_wide_line_draw   = _gx_dave2d_rotated_aliased_wide_line;\n";

        out += "    display -> gx_display_driver_pixelmap_blend                = _gx_dave2d_rotated_pixelmap_blend;\n";

        out += "    display -> gx_display_driver_8bit_glyph_draw               = _gx_dave2d_rotated_raw_glyph_8bit_draw;\n";
        out += "    display -> gx_display_driver_4bit_glyph_draw               = _gx_dave2d_rotated_raw_glyph_4bit_draw;\n";
        out += "    display -> gx_display_driver_1bit_glyph_draw               = _gx_dave2d_rotated_raw_glyph_1bit_draw;\n";
        out += "    display -> gx_display_driver_8bit_compressed_glyph_draw    = _gx_dave2d_rotated_compressed_glyph_8bit_draw;\n";
        out += "    display -> gx_display_driver_4bit_compressed_glyph_draw    = _gx_dave2d_rotated_compressed_glyph_4bit_draw;\n";
        out += "    display -> gx_display_driver_1bit_compressed_glyph_draw    = _gx_dave2d_rotated_compressed_glyph_1bit_draw;\n";

        out += "    #if defined(GX_ARC_DRAWING_SUPPORT)\n";
        out += "    display -> gx_display_driver_anti_aliased_circle_draw      = _gx_dave2d_rotated_aliased_circle_draw;\n";
        out += "    display -> gx_display_driver_anti_aliased_wide_circle_draw = _gx_dave2d_rotated_aliased_circle_draw;\n";
        out += "    display -> gx_display_driver_circle_draw                   = _gx_dave2d_rotated_circle_draw;\n";
        out += "    display -> gx_display_driver_circle_fill                   = _gx_dave2d_rotated_circle_fill;\n";
        out += "    display -> gx_display_driver_pie_fill                      = _gx_dave2d_rotated_pie_fill;\n";
        out += "    display -> gx_display_driver_anti_aliased_arc_draw         = _gx_dave2d_rotated_aliased_arc_draw;\n";
        out += "    display -> gx_display_driver_arc_draw                      = _gx_dave2d_rotated_arc_draw;\n";
        out += "    display -> gx_display_driver_arc_fill                      = _gx_dave2d_rotated_arc_fill;\n";
        out += "    display -> gx_display_driver_anti_aliased_ellipse_draw     = _gx_dave2d_rotated_aliased_ellipse_draw;\n";
        out += "    display -> gx_display_driver_ellipse_draw                  = _gx_dave2d_rotated_ellipse_draw;\n";
        out += "    display -> gx_display_driver_ellipse_fill                  = _gx_dave2d_rotated_ellipse_fill;\n";
        out += "    display -> gx_display_driver_wide_circle_draw              = _gx_dave2d_rotated_circle_draw;\n";
        out += "    display -> gx_display_driver_anti_aliased_wide_arc_draw    = _gx_dave2d_rotated_aliased_arc_draw;\n";
        out += "    display -> gx_display_driver_wide_arc_draw                 = _gx_dave2d_rotated_arc_draw;\n";

        out += "    display -> gx_display_driver_anti_aliased_wide_ellipse_draw= _gx_dave2d_rotated_aliased_ellipse_draw;\n";
        out += "    display -> gx_display_driver_wide_ellipse_draw             = _gx_dave2d_rotated_ellipse_draw;\n";

        out += "    #endif\n";
    }

    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::WriteDave2DSetupFunction(int display)
{
    // Fixme:gx_synergy_display_driver_setup function will generated once for every display,
    // just generate this function definition when display is 0 to fix the issue temporarily
    // This won't work when multi display have different color format
    if (display > 0)
    {
        return;
    }

    CString out;
    FileWrite(CString("#if defined(GX_TARGET_WIN32) || defined(GX_TARGET_LINUX)\n"));

    switch(m_project->mHeader.target_cpu)
    {
    case CPU_RA:
        out.Format(_T("\nUINT _gx_ra_display_driver_setup(GX_DISPLAY *display)\n{\n"));
        break;

    case CPU_RX:
        out.Format(_T("\nUINT _gx_rx_display_driver_setup(GX_DISPLAY *display)\n{\n"));
        break;

    default:  // synergy
        out.Format(_T("\nUINT _gx_synergy_display_driver_setup(GX_DISPLAY *display)\n{\n"));
        break;
    }

    /* prototype the driver setup function */
    switch(m_project->mDisplays[display].colorformat)
    {
    case GX_COLOR_FORMAT_8BIT_PALETTE:
        if (resource_gen::IsRotatedResourceSupported(m_project, m_display))
        {
            out += "    win32_graphics_driver_setup_8bit_palette_rotated(display);\n";
        }
        else
        {
            if (IsDave2dFontFormat(m_project, display))
            {
                out += "    win32_dave2d_graphics_driver_setup_8bit_palette(display);\n";
            }
            else
            {
                out += "    win32_graphics_driver_setup_8bit_palette(display);\n";
            }
        }

        out += "    return GX_SUCCESS;\n}\n";
        
        switch (m_project->mHeader.target_cpu)
        {
        case CPU_RA:
            out += "#else\nUINT _gx_ra_display_driver_setup(GX_DISPLAY *display)\n{\n";
            break;

        case CPU_RX:
            out += "#else\nUINT _gx_rx_display_driver_setup(GX_DISPLAY *display)\n{\n";
            break;

        default:  // synergy
            out += "#else\nUINT _gx_synergy_display_driver_setup(GX_DISPLAY *display)\n{\n";
            break;
        }

        FileWrite(out);

        if (resource_gen::IsRotatedResourceSupported(m_project, m_display))
        {
            WriteDave2D8bppPaletteRotatedSetup();
        }
        else
        {
            WriteDave2D8bppPaletteSetup();
        }
        break;

    case GX_COLOR_FORMAT_565RGB:
        if (resource_gen::IsRotatedResourceSupported(m_project, m_display))
        {
            if (IsRenesasDave2D(m_project))
            {
                out += "    win32_dave2d_graphics_driver_setup_565rgb_rotated(display);\n";
            }
            else
            {
                out += "    win32_graphics_driver_setup_565rgb_rotated(display);\n";
            }
        }
        else
        {
            if (IsRenesasDave2D(m_project))
            {
                out += "    win32_dave2d_graphics_driver_setup_565rgb(display);\n";
            }
            else
            {
                out += "    win32_graphics_driver_setup_565rgb(display);\n";
            }
        }

        out += "    return GX_SUCCESS;\n}\n";
        switch (m_project->mHeader.target_cpu)
        {
        case CPU_RA:
            out += "#else\nUINT _gx_ra_display_driver_setup(GX_DISPLAY *display)\n{\n";
            break;

        case CPU_RX:
            out += "#else\nUINT _gx_rx_display_driver_setup(GX_DISPLAY *display)\n{\n";
            break;

        default:  // synergy
            out += "#else\nUINT _gx_synergy_display_driver_setup(GX_DISPLAY *display)\n{\n";
            break;
        }        
        FileWrite(out);
        if (resource_gen::IsRotatedResourceSupported(m_project, m_display))
        {
            WriteDave2D16_32_RotatedSetup(m_project->mDisplays[display].colorformat);
        }
        else
        {
            WriteDave2D16_32_Setup(m_project->mDisplays[display].colorformat);
        }
        break;

    default:
        if (resource_gen::IsRotatedResourceSupported(m_project, m_display))
        {
            if (IsRenesasDave2D(m_project))
            {
                out += "    win32_dave2d_graphics_driver_setup_24xrgb_rotated(display);\n";
            }
            else
            {
                out += "    win32_graphics_driver_setup_24xrgb_rotated(display);\n";
            }
        }
        else
        {
            if (IsRenesasDave2D(m_project))
            {
                out += "    win32_dave2d_graphics_driver_setup_24xrgb(display);\n";
            }
            else
            {
                out += "    win32_graphics_driver_setup_24xrgb(display);\n";
            }
        }
        out += "    return GX_SUCCESS;\n}\n";
        switch (m_project->mHeader.target_cpu)
        {
        case CPU_RA:
            out += "#else\nUINT _gx_ra_display_driver_setup(GX_DISPLAY *display)\n{\n";
            break;

        case CPU_RX:
            out += "#else\nUINT _gx_rx_display_driver_setup(GX_DISPLAY *display)\n{\n";
            break;

        default:  // synergy
            out += "#else\nUINT _gx_synergy_display_driver_setup(GX_DISPLAY *display)\n{\n";
            break;
        } 
        FileWrite(out);
        if (resource_gen::IsRotatedResourceSupported(m_project, m_display))
        {
            WriteDave2D16_32_RotatedSetup(m_project->mDisplays[display].colorformat);
        }
        else
        {
            WriteDave2D16_32_Setup(m_project->mDisplays[display].colorformat);
        }
        break;

    }
    out.Format(_T("    return GX_SUCCESS;\n}\n#endif\n"));
    FileWrite(out);
}

///////////////////////////////////////////////////////////////////////////////
void screen_generator::DeclareSynergyDriverFunctions(void)
{
    CString out;
    int display;
    BOOL bNeed8bit = FALSE;
    BOOL bNeed16bit = FALSE;
    BOOL bNeed24bit = FALSE;
    BOOL bNeed32bit = FALSE;
    BOOL bNeed32bitRotated = FALSE;
    BOOL bNeed24bitRotated = FALSE;
    BOOL bNeed16bitRotated = FALSE;
    BOOL bNeed8bitRotated = FALSE;

    WriteComment("Prototype Dave2D display driver specific functions");

    for (display = 0; display < m_project->mHeader.num_displays; display++)
    {
        switch(m_project->mDisplays[display].colorformat)
        {
        case GX_COLOR_FORMAT_565RGB:
            if (resource_gen::IsRotatedResourceSupported(m_project, m_display))
            {
                bNeed16bitRotated = TRUE;
            }
            else
            {
                bNeed16bit = TRUE;
            }
            break;

        case GX_COLOR_FORMAT_8BIT_PALETTE:
            if (resource_gen::IsRotatedResourceSupported(m_project, m_display))
            {
                bNeed8bitRotated = TRUE;
            }
            else
            {
                bNeed8bit = TRUE;
            }
            break;

        case GX_COLOR_FORMAT_24XRGB:
            if (resource_gen::IsRotatedResourceSupported(m_project, m_display))
            {
                bNeed24bitRotated = TRUE;
            }
            else
            {
                bNeed24bit = TRUE;
            }
            break;

        case GX_COLOR_FORMAT_32ARGB:
            if (resource_gen::IsRotatedResourceSupported(m_project, m_display))
            {
                bNeed32bitRotated = TRUE;
            }
            else
            {
                bNeed32bit = TRUE;
            }
            break;
        }
    }

    switch(m_project->mHeader.target_cpu)
    {
    case CPU_RA:
        out = "UINT _gx_ra_display_driver_setup(GX_DISPLAY *display);\n";
        break;

    case CPU_RX:
        out = "UINT _gx_rx_display_driver_setup(GX_DISPLAY *display);\n";
        break;

    default:
        out = "UINT _gx_synergy_display_driver_setup(GX_DISPLAY *display);\n";
        break;
    }
    FileWrite(out);

    out = "#if defined(GX_TARGET_WIN32) || defined(GX_TARGET_LINUX)\n";
    if (IsDave2dFontFormat(m_project, display))
    {
        if (bNeed8bit)
        {
            out += "UINT win32_dave2d_graphics_driver_setup_8bit_palette(GX_DISPLAY *display);\n";
        }

        if (bNeed16bit)
        {
            out += "UINT win32_dave2d_graphics_driver_setup_565rgb(GX_DISPLAY *display);\n";
        }
        if (bNeed16bitRotated)
        {
            out += "UINT win32_dave2d_graphics_driver_setup_565rgb_rotated(GX_DISPLAY *display);\n";
        }
        if (bNeed24bit || bNeed32bit)
        {
            out += "UINT win32_dave2d_graphics_driver_setup_24xrgb(GX_DISPLAY *display);\n";
        }
        if (bNeed24bitRotated || bNeed32bitRotated)
        {
            out += "UINT win32_dave2d_graphics_driver_setup_24xrgb_rotated(GX_DISPLAY *display);\n";
        }
    }
    else
    {
        if (bNeed8bit)
        {
            out += "UINT win32_graphics_driver_setup_8bit_palette(GX_DISPLAY *display);\n";
        }

        if (bNeed16bit)
        {
            out += "UINT win32_graphics_driver_setup_565rgb(GX_DISPLAY *display);\n";
        }
        if (bNeed16bitRotated)
        {
            out += "UINT win32_graphics_driver_setup_565rgb_rotated(GX_DISPLAY *display);\n";
        }
        if (bNeed24bit || bNeed32bit)
        {
            out += "UINT win32_graphics_driver_setup_24xrgb(GX_DISPLAY *display);\n";
        }
        if (bNeed24bitRotated || bNeed32bitRotated)
        {
            out += "UINT win32_graphics_driver_setup_24xrgb_rotated(GX_DISPLAY *display);\n";
        }
    }

    if (bNeed8bitRotated)
    {
        out += "UINT win32_graphics_driver_setup_8bit_palette_rotated(GX_DISPLAY *display);\n";
    }

    out += "#else\n";
    FileWrite(out);

    if (bNeed8bit)
    {
        out = "VOID _gx_display_driver_8bit_palette_setup(GX_DISPLAY *display, VOID *aux_data,\n"
              "                           VOID (*toggle_function)(struct GX_CANVAS_STRUCT *canvas,\n"
              "                           GX_RECTANGLE *dirty_area));\n";
        out += "VOID _gx_display_driver_8bit_palette_assign(GX_DISPLAY *display, GX_COLOR *palette, INT count);\n";
        FileWrite(out);

        if (IsRenesasDave2D(m_project))
        {
            out = "VOID _gx_dave2d_drawing_initiate_8bpp(GX_DISPLAY *display, GX_CANVAS *canvas);\n";
            out += "VOID _gx_dave2d_drawing_complete_8bpp(GX_DISPLAY *display, GX_CANVAS *canvas);\n";
            out += "VOID _gx_dave2d_horizontal_line_8bpp(GX_DRAW_CONTEXT *context,\n"
                   "                                     INT xstart, INT xend, INT ypos, INT width, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_vertical_line_8bpp(GX_DRAW_CONTEXT *context,\n"
                   "                                   INT ystart, INT yend, INT xpos, INT width, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_simple_line_draw_8bpp(GX_DRAW_CONTEXT *context, INT xstart, INT ystart, INT xend, INT yend);\n";
            out += "VOID _gx_dave2d_simple_wide_line_8bpp(GX_DRAW_CONTEXT *context, INT xstart, INT ystart,\n"
                   "                                INT xend, INT yend);\n";
            out += "VOID _gx_dave2d_horizontal_pattern_line_draw_8bpp(GX_DRAW_CONTEXT *context, INT xstart, INT xend, INT ypos);\n";
            out += "VOID _gx_dave2d_vertical_pattern_line_draw_8bpp(GX_DRAW_CONTEXT *context, INT ystart, INT yend, INT xpos);\n";
            out += "VOID _gx_dave2d_pixelmap_draw_8bpp(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, GX_PIXELMAP *pixelmap);\n";
            out += "VOID _gx_dave2d_polygon_draw_8bpp(GX_DRAW_CONTEXT *context, GX_POINT *vertex, INT num);\n";
            out += "VOID _gx_dave2d_polygon_fill_8bpp(GX_DRAW_CONTEXT *context, GX_POINT *vertex, INT num);\n";
            out += "VOID _gx_dave2d_pixel_write_8bpp(GX_DRAW_CONTEXT *context, INT x, INT y, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_block_move_8bpp(GX_DRAW_CONTEXT *context,\n"
                   "                           GX_RECTANGLE *block, INT xshift, INT yshift);\n";
            out += "VOID _gx_dave2d_canvas_copy(GX_CANVAS *canvas, GX_CANVAS *composite);\n";
            out += "VOID _gx_dave2d_glyph_1bit_draw_8bpp(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
            if (project_lib_version() >= GX_VERSION_SYNERGY_GLYPH_GEN_CHANGE)
            {
                out += "VOID _gx_dave2d_glyph_3bit_draw_8bpp(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
            }
            out += "VOID _gx_dave2d_glyph_4bit_draw_8bpp(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
            out += "#if defined(GX_ARC_DRAWING_SUPPORT)\n";
            out += "VOID _gx_dave2d_circle_draw_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r);\n";
            out += "VOID _gx_dave2d_circle_fill_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r);\n";
            out += "VOID _gx_dave2d_arc_draw_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
            out += "VOID _gx_dave2d_arc_fill_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
            out += "VOID _gx_dave2d_pie_fill_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
            out += "VOID _gx_dave2d_ellipse_draw_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
            out += "VOID _gx_dave2d_wide_ellipse_draw_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
            out += "VOID _gx_dave2d_ellipse_fill_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
            out += "#endif\n";
            out += "VOID _gx_dave2d_buffer_toggle_8bpp(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
        }
        else
        {
            switch(m_project->mHeader.target_cpu)
            {
            case CPU_RA:
                out = "VOID _gx_ra_buffer_toggle_8bpp(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
                break;

            case CPU_RX:
                out = "VOID _gx_rx_buffer_toggle_8bpp(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
                break;

            default:
                out = "VOID _gx_synergy_buffer_toggle_8bpp(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
                break;
            }
        }
        FileWrite(out);
    }

    if (bNeed8bitRotated)
    {
        out = "VOID _gx_display_driver_8bit_palette_rotated_setup(GX_DISPLAY *display, VOID *aux_data,\n"
            "                                                     VOID (*toggle_function)(struct GX_CANVAS_STRUCT *canvas,\n"
            "                                                     GX_RECTANGLE *dirty_area));\n";
        out += "VOID _gx_display_driver_8bit_palette_assign(GX_DISPLAY *display, GX_COLOR *palette, INT count);\n";
        FileWrite(out);

        if (IsRenesasDave2D(m_project))
        {
            out = "VOID _gx_dave2d_drawing_initiate_8bpp(GX_DISPLAY *display, GX_CANVAS *canvas);\n";
            out += "VOID _gx_dave2d_drawing_complete_8bpp(GX_DISPLAY *display, GX_CANVAS *canvas);\n";
            out += "VOID _gx_dave2d_rotated_horizontal_line_8bpp(GX_DRAW_CONTEXT *context,\n"
                "                                     INT xstart, INT xend, INT ypos, INT width, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_rotated_vertical_line_8bpp(GX_DRAW_CONTEXT *context,\n"
                "                                   INT ystart, INT yend, INT xpos, INT width, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_rotated_simple_line_draw_8bpp(GX_DRAW_CONTEXT *context, INT xstart, INT ystart, INT xend, INT yend);\n";
            out += "VOID _gx_dave2d_rotated_simple_wide_line_8bpp(GX_DRAW_CONTEXT *context, INT xstart, INT ystart,\n"
                "                                INT xend, INT yend);\n";
            out += "VOID _gx_dave2d_rotated_horizontal_pattern_line_draw_8bpp(GX_DRAW_CONTEXT *context, INT xstart, INT xend, INT ypos);\n";
            out += "VOID _gx_dave2d_rotated_vertical_pattern_line_draw_8bpp(GX_DRAW_CONTEXT *context, INT ystart, INT yend, INT xpos);\n";
            out += "VOID _gx_dave2d_rotated_pixelmap_draw_8bpp(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, GX_PIXELMAP *pixelmap);\n";
            out += "VOID _gx_dave2d_rotated_polygon_draw_8bpp(GX_DRAW_CONTEXT *context, GX_POINT *vertex, INT num);\n";
            out += "VOID _gx_dave2d_rotated_polygon_fill_8bpp(GX_DRAW_CONTEXT *context, GX_POINT *vertex, INT num);\n";
            out += "VOID _gx_dave2d_rotated_pixel_write_8bpp(GX_DRAW_CONTEXT *context, INT x, INT y, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_rotated_block_move_8bpp(GX_DRAW_CONTEXT *context,\n"
                "                           GX_RECTANGLE *block, INT xshift, INT yshift);\n";
            out += "VOID _gx_dave2d_rotated_canvas_copy(GX_CANVAS *canvas, GX_CANVAS *composite);\n";
            out += "VOID _gx_dave2d_rotated_glyph_1bit_draw_8bpp(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
            out += "VOID _gx_dave2d_rotated_glyph_3bit_draw_8bpp(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
            out += "VOID _gx_dave2d_rotated_glyph_4bit_draw_8bpp(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
            out += "#if defined(GX_ARC_DRAWING_SUPPORT)\n";
            out += "VOID _gx_dave2d_rotated_circle_draw_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r);\n";
            out += "VOID _gx_dave2d_rotated_circle_fill_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r);\n";
            out += "VOID _gx_dave2d_rotated_arc_draw_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
            out += "VOID _gx_dave2d_rotated_arc_fill(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
            out += "VOID _gx_dave2d_rotated_pie_fill_8bpp(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
            out += "VOID _gx_dave2d_rotated_ellipse_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
            out += "VOID _gx_dave2d_rotated_ellipse_fill(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
            out += "#endif\n";
            out += "VOID _gx_dave2d_rotated_buffer_toggle_8bpp(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
        }
        else
        {
            switch (m_project->mHeader.target_cpu)
            {
            case CPU_RA:
                out = "VOID _gx_ra_rotated_buffer_toggle_8bpp(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
                break;

            case CPU_RX:
                out = "VOID _gx_rx_rotated_buffer_toggle_8bpp(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
                break;

            default:
                out = "VOID _gx_synergy_rotated_buffer_toggle_8bpp(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
                break;
            }
        }
        FileWrite(out);
    }

    if (bNeed16bit)
    {
        out = "VOID _gx_display_driver_565rgb_setup(GX_DISPLAY *display, VOID *aux_data,\n"
              "                           VOID (*toggle_function)(struct GX_CANVAS_STRUCT *canvas,\n"
              "                           GX_RECTANGLE *dirty_area));\n";
        if (IsRenesasDave2D(m_project))
        {
            out += "VOID _gx_dave2d_horizontal_pattern_line_draw_565(GX_DRAW_CONTEXT *context, INT xstart, INT xend, INT ypos);\n";
            out += "VOID _gx_dave2d_vertical_pattern_line_draw_565(GX_DRAW_CONTEXT *context, INT ystart, INT yend, INT xpos);\n";
            out += "VOID _gx_dave2d_pixel_write_565(GX_DRAW_CONTEXT *context, INT x, INT y, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_pixel_blend_565(GX_DRAW_CONTEXT *context, INT x, INT y, GX_COLOR fcolor, GX_UBYTE alpha);\n";
            if (m_project->mHeader.guix_version > 50303)
            {
                out += "VOID _gx_dave2d_pixelmap_rotate_16bpp(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, GX_PIXELMAP *pixelmap, INT angle, INT rot_cx, INT rot_cy);\n";
            }
        }

        FileWrite(out);
    }

    if (bNeed16bitRotated)
    {
        out = "VOID _gx_display_driver_565rgb_rotated_setup(GX_DISPLAY *display, VOID *aux_data,\n"
            "                                               VOID (*toggle_function)(struct GX_CANVAS_STRUCT *canvas,\n"
            "                                               GX_RECTANGLE *dirty_area));\n";
        if (IsRenesasDave2D(m_project))
        {
            out += "VOID _gx_dave2d_rotated_horizontal_pattern_line_draw_565(GX_DRAW_CONTEXT *context, INT xstart, INT xend, INT ypos);\n";
            out += "VOID _gx_dave2d_rotated_vertical_pattern_line_draw_565(GX_DRAW_CONTEXT *context, INT ystart, INT yend, INT xpos);\n";
            out += "VOID _gx_dave2d_rotated_pixel_write_565(GX_DRAW_CONTEXT *context, INT x, INT y, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_rotated_pixel_blend_565(GX_DRAW_CONTEXT *context, INT x, INT y, GX_COLOR fcolor, GX_UBYTE alpha);\n";
            out += "VOID _gx_dave2d_rotated_pixelmap_rotate_16bpp(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, GX_PIXELMAP *pixelmap, INT angle, INT rot_cx, INT rot_cy);\n";
        }

        FileWrite(out);
    }
    
    if (bNeed24bit || bNeed32bit)
    {
        out = "";

        if (IsRenesasDave2D(m_project))
        {
            out += "VOID _gx_display_driver_32argb_setup(GX_DISPLAY *display, VOID *aux_data,\n"
                   "                           VOID (*toggle_function)(struct GX_CANVAS_STRUCT *canvas,\n"
                   "                           GX_RECTANGLE *dirty_area));\n";

            out += "VOID _gx_dave2d_horizontal_pattern_line_draw_888(GX_DRAW_CONTEXT *context, INT xstart, INT xend, INT ypos);\n";
            out += "VOID _gx_dave2d_vertical_pattern_line_draw_888(GX_DRAW_CONTEXT *context, INT ystart, INT yend, INT xpos);\n";
            out += "VOID _gx_dave2d_pixel_write_888(GX_DRAW_CONTEXT *context, INT x, INT y, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_pixel_blend_888(GX_DRAW_CONTEXT *context, INT x, INT y, GX_COLOR fcolor, GX_UBYTE alpha);\n";
        }
        else
        {
            if (bNeed24bit)
            {
                out += "VOID _gx_display_driver_24xrgb_setup(GX_DISPLAY *display, VOID *aux_data,\n"
                       "                           VOID (*toggle_function)(struct GX_CANVAS_STRUCT *canvas,\n"
                       "                           GX_RECTANGLE *dirty_area));\n";
            }
            if (bNeed32bit)
            {
                out += "VOID _gx_display_driver_32argb_setup(GX_DISPLAY *display, VOID *aux_data,\n"
                       "                           VOID (*toggle_function)(struct GX_CANVAS_STRUCT *canvas,\n"
                       "                           GX_RECTANGLE *dirty_area));\n";
            }
        }
 
        FileWrite(out);
    }

    if (bNeed24bitRotated || bNeed32bitRotated)
    {
        out = "";

        if (bNeed24bitRotated)
        {
            out += "VOID _gx_display_driver_24xrgb_rotated_setup(GX_DISPLAY *display, VOID *aux_data,\n"
                   "                           VOID (*toggle_function)(struct GX_CANVAS_STRUCT *canvas,\n"
                   "                           GX_RECTANGLE *dirty_area));\n";
        }
        if (bNeed32bitRotated)
        {
            out += "VOID _gx_display_driver_32argb_rotated_setup(GX_DISPLAY *display, VOID *aux_data,\n"
                   "                           VOID (*toggle_function)(struct GX_CANVAS_STRUCT *canvas,\n"
                   "                           GX_RECTANGLE *dirty_area));\n";
        }

        if (IsRenesasDave2D(m_project))
        {
            out += "VOID _gx_dave2d_rotated_horizontal_pattern_line_draw_888(GX_DRAW_CONTEXT *context, INT xstart, INT xend, INT ypos);\n";
            out += "VOID _gx_dave2d_rotated_vertical_pattern_line_draw_888(GX_DRAW_CONTEXT *context, INT ystart, INT yend, INT xpos);\n";
            out += "VOID _gx_dave2d_rotated_pixel_write_888(GX_DRAW_CONTEXT *context, INT x, INT y, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_rotated_pixel_blend_888(GX_DRAW_CONTEXT *context, INT x, INT y, GX_COLOR fcolor, GX_UBYTE alpha);\n";
        }

        FileWrite(out);
    }

    if (bNeed16bit || bNeed24bit || bNeed32bit)
    {
        if (IsRenesasDave2D(m_project))
        {
            out = "VOID _gx_dave2d_drawing_initiate(GX_DISPLAY *display, GX_CANVAS *canvas);\n";
            out += "VOID _gx_dave2d_drawing_complete(GX_DISPLAY *display, GX_CANVAS *canvas);\n";
            out += "VOID _gx_dave2d_horizontal_line(GX_DRAW_CONTEXT *context,\n";
            out += "                             INT xstart, INT xend, INT ypos, INT width, GX_COLOR color);\n";
            out += "VOID _gx_dave2d_vertical_line(GX_DRAW_CONTEXT *context,\n";
            out += "                             INT ystart, INT yend, INT xpos, INT width, GX_COLOR color);\n";

            out += "VOID _gx_dave2d_canvas_copy(GX_CANVAS *canvas, GX_CANVAS *composite);\n";
            out += "VOID _gx_dave2d_canvas_blend(GX_CANVAS *canvas, GX_CANVAS *composite);\n";
            out += "VOID _gx_dave2d_simple_line_draw(GX_DRAW_CONTEXT *context, INT xstart, INT ystart, INT xend, INT yend);\n";
            out += "VOID _gx_dave2d_simple_wide_line(GX_DRAW_CONTEXT *context, INT xstart, INT ystart,\n";
            out += "                                INT xend, INT yend);\n";
            out += "VOID _gx_dave2d_aliased_line(GX_DRAW_CONTEXT *context, INT xstart, INT ystart, INT xend, INT yend);\n";
            out += "VOID _gx_dave2d_aliased_wide_line(GX_DRAW_CONTEXT *context, INT xstart,\n";
            out += "                                        INT ystart, INT xend, INT yend);\n";
            out += "VOID _gx_dave2d_pixelmap_draw(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, GX_PIXELMAP *pixelmap);\n";
            if (m_project->mHeader.guix_version < 50400)
            {
                out += "VOID _gx_dave2d_horizontal_pixelmap_line_draw(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, INT xstart, INT xend, INT y, GX_PIXELMAP *pixelmap);\n";
            }
            else if (m_project->mHeader.guix_version <= 50500)
            {
                out += "VOID _gx_dave2d_horizontal_pixelmap_line_draw(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, INT xstart, INT xend, INT y, GX_FILL_PIXELMAP_INFO *info);\n";
            }
            else
            {
                out += "VOID _gx_dave2d_horizontal_pixelmap_line_draw(GX_DRAW_CONTEXT *context, INT xstart, INT xend, INT y, GX_FILL_PIXELMAP_INFO *info);\n";
            }
            out += "VOID _gx_dave2d_pixelmap_blend(GX_DRAW_CONTEXT *context, INT xpos, INT ypos,\n";
            out += "                                      GX_PIXELMAP *pixelmap, GX_UBYTE alpha);\n";
            out += "VOID _gx_dave2d_polygon_draw(GX_DRAW_CONTEXT *context, GX_POINT *vertex, INT num);\n";
            out += "VOID _gx_dave2d_polygon_fill(GX_DRAW_CONTEXT *context, GX_POINT *vertex, INT num);\n";
            out += "VOID _gx_dave2d_block_move(GX_DRAW_CONTEXT *context,\n";
            out += "                          GX_RECTANGLE *block, INT xshift, INT yshift);\n";
            out += "VOID _gx_dave2d_alphamap_draw(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, GX_PIXELMAP *pixelmap);\n";
            if (m_project->mHeader.guix_version < 50303)
            {
                out += "VOID _gx_dave2d_glyph_8bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
                out += "VOID _gx_dave2d_glyph_4bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
                out += "VOID _gx_dave2d_glyph_1bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
            }
            else
            {
                out += "VOID _gx_dave2d_compressed_glyph_8bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
                out += "VOID _gx_dave2d_raw_glyph_8bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
                out += "VOID _gx_dave2d_compressed_glyph_4bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
                out += "VOID _gx_dave2d_raw_glyph_4bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
                out += "VOID _gx_dave2d_compressed_glyph_1bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
                out += "VOID _gx_dave2d_raw_glyph_1bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
            }
            out += "VOID _gx_dave2d_buffer_toggle(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
            out += "#if defined(GX_ARC_DRAWING_SUPPORT)\n";
            out += "VOID _gx_dave2d_aliased_circle_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r);\n";
            out += "VOID _gx_dave2d_circle_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r);\n";
            out += "VOID _gx_dave2d_circle_fill(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r);\n";
            out += "VOID _gx_dave2d_pie_fill(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
            out += "VOID _gx_dave2d_aliased_arc_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
            out += "VOID _gx_dave2d_arc_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
            out += "VOID _gx_dave2d_arc_fill(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
            out += "VOID _gx_dave2d_aliased_ellipse_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
            out += "VOID _gx_dave2d_ellipse_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
            out += "VOID _gx_dave2d_ellipse_fill(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
            out += "#endif\n";
        }
        else
        {
            switch (m_project->mHeader.target_cpu)
            {
            case CPU_RA:
                out = "VOID _gx_ra_buffer_toggle(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
                break;

            case CPU_RX:
                out = "VOID _gx_rx_buffer_toggle(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
                break;

            default:
                out = "VOID _gx_synergy_buffer_toggle(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
                break;
            }
        }

        FileWrite(out);
    }

    if ((bNeed16bitRotated || bNeed24bitRotated || bNeed32bitRotated) && IsRenesasDave2D(m_project))
    {
        out = "VOID _gx_dave2d_rotated_drawing_initiate(GX_DISPLAY *display, GX_CANVAS *canvas);\n";
        out += "VOID _gx_dave2d_rotated_drawing_complete(GX_DISPLAY *display, GX_CANVAS *canvas);\n";
        out += "VOID _gx_dave2d_rotated_horizontal_line(GX_DRAW_CONTEXT *context,\n";
        out += "                                        INT xstart, INT xend, INT ypos, INT width, GX_COLOR color);\n";
        out += "VOID _gx_dave2d_rotated_vertical_line(GX_DRAW_CONTEXT *context,\n";
        out += "                                      INT ystart, INT yend, INT xpos, INT width, GX_COLOR color);\n";

        out += "VOID _gx_dave2d_rotated_canvas_copy(GX_CANVAS *canvas, GX_CANVAS *composite);\n";
        out += "VOID _gx_dave2d_rotated_canvas_blend(GX_CANVAS *canvas, GX_CANVAS *composite);\n";
        out += "VOID _gx_dave2d_rotated_simple_line_draw(GX_DRAW_CONTEXT *context, INT xstart, INT ystart, INT xend, INT yend);\n";
        out += "VOID _gx_dave2d_rotated_simple_wide_line(GX_DRAW_CONTEXT *context, INT xstart, INT ystart,\n";
        out += "                                         INT xend, INT yend);\n";
        out += "VOID _gx_dave2d_rotated_aliased_line(GX_DRAW_CONTEXT *context, INT xstart, INT ystart, INT xend, INT yend);\n";
        out += "VOID _gx_dave2d_rotated_aliased_wide_line(GX_DRAW_CONTEXT *context, INT xstart,\n";
        out += "                                          INT ystart, INT xend, INT yend);\n";
        out += "VOID _gx_dave2d_rotated_pixelmap_draw(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, GX_PIXELMAP *pixelmap);\n";
        out += "VOID _gx_dave2d_rotated_horizontal_pixelmap_line_draw(GX_DRAW_CONTEXT *context, INT xstart, INT xend, INT y, GX_FILL_PIXELMAP_INFO *info);\n";
        out += "VOID _gx_dave2d_rotated_pixelmap_blend(GX_DRAW_CONTEXT *context, INT xpos, INT ypos,\n";
        out += "                                       GX_PIXELMAP *pixelmap, GX_UBYTE alpha);\n";
        out += "VOID _gx_dave2d_rotated_polygon_draw(GX_DRAW_CONTEXT *context, GX_POINT *vertex, INT num);\n";
        out += "VOID _gx_dave2d_rotated_polygon_fill(GX_DRAW_CONTEXT *context, GX_POINT *vertex, INT num);\n";
        out += "VOID _gx_dave2d_rotated_block_move(GX_DRAW_CONTEXT *context,\n";
        out += "                                   GX_RECTANGLE *block, INT xshift, INT yshift);\n";
        out += "VOID _gx_dave2d_rotated_alphamap_draw(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, GX_PIXELMAP *pixelmap);\n";
        out += "VOID _gx_dave2d_rotated_compressed_glyph_8bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
        out += "VOID _gx_dave2d_rotated_raw_glyph_8bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
        out += "VOID _gx_dave2d_rotated_compressed_glyph_4bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
        out += "VOID _gx_dave2d_rotated_raw_glyph_4bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
        out += "VOID _gx_dave2d_rotated_compressed_glyph_1bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
        out += "VOID _gx_dave2d_rotated_raw_glyph_1bit_draw(GX_DRAW_CONTEXT *context, GX_RECTANGLE *draw_area, GX_POINT *map_offset, const GX_GLYPH *glyph);\n";
        out += "VOID _gx_dave2d_rotated_buffer_toggle(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
        out += "#if defined(GX_ARC_DRAWING_SUPPORT)\n";
        out += "VOID _gx_dave2d_rotated_aliased_circle_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r);\n";
        out += "VOID _gx_dave2d_rotated_circle_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r);\n";
        out += "VOID _gx_dave2d_rotated_circle_fill(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r);\n";
        out += "VOID _gx_dave2d_rotated_pie_fill(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
        out += "VOID _gx_dave2d_rotated_aliased_arc_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
        out += "VOID _gx_dave2d_rotated_arc_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
        out += "VOID _gx_dave2d_rotated_arc_fill(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, UINT r, INT start_angle, INT end_angle);\n";
        out += "VOID _gx_dave2d_rotated_aliased_ellipse_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
        out += "VOID _gx_dave2d_rotated_ellipse_draw(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
        out += "VOID _gx_dave2d_rotated_ellipse_fill(GX_DRAW_CONTEXT *context, INT xcenter, INT ycenter, INT a, INT b);\n";
        out += "#endif\n";

        FileWrite(out);
    }

    if ((bNeed16bitRotated || bNeed24bitRotated || bNeed32bitRotated) && !IsRenesasDave2D(m_project))
    {
        switch (m_project->mHeader.target_cpu)
        {
        case CPU_RA:
            out = "VOID _gx_ra_rotated_buffer_toggle(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
            break;

        case CPU_RX:
            out = "VOID _gx_rx_rotated_buffer_toggle(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
            break;

        default:
            out = "VOID _gx_synergy_rotated_buffer_toggle(GX_CANVAS *canvas, GX_RECTANGLE *dirty);\n";
            break;
        }
        FileWrite(out);
    }

    if (m_project->mHeader.renesas_jpeg_decoder == DECODER_TYPE_HW)
    {
        if (m_project->mHeader.target_cpu == CPU_SYNERGY)
        {
            out = "VOID _gx_synergy_jpeg_draw (GX_DRAW_CONTEXT *p_context, INT x, INT y, GX_PIXELMAP *p_pixelmap);\n";
        }
        else
        {
            out = "VOID _gx_renesas_jpeg_draw (GX_DRAW_CONTEXT *p_context, INT x, INT y, GX_PIXELMAP *p_pixelmap);\n";
        }
        FileWrite(out);
    }

    if (m_project->mHeader.renesas_png_decoder == DECODER_TYPE_SW &&
        IsRenesasDave2D(m_project) && (project_lib_version() >= GX_VERSION_USE_DAVE2D_PNG_DRAW))
    {
        if (bNeed16bit || bNeed24bit || bNeed32bit)
        {
            out = "VOID _gx_dave2d_png_draw(GX_DRAW_CONTEXT *context, INT xpos, INT ypos, GX_PIXELMAP *pixelmap);\n";
            FileWrite(out);
        }
    }
    FileWrite(CString("\n#endif\n"));
}

